<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Solow 增长模型</title>
    <link href="/2023/02/11/solow-model/"/>
    <url>/2023/02/11/solow-model/</url>
    
    <content type="html"><![CDATA[<h2 id="一基本假设">一、基本假设</h2><h3 id="生产过程">1.生产过程</h3><p>我们首先假设，一个经济体在超长期中的生产过程，可以被分成无数个相继发生的短期生产过程。在经济体的每一期生产过程中，都有一定量的资本和劳动相结合，在一定的技术条件下，生产出一定量的产品。这些产品一部分用于这一期的消费，还有一部分用于投资，为下一期的生产做准备。</p><p>单个短期生产过程的图示为： <pre><code class=" mermaid">flowchart LRcapital(资本 K) &amp; labour(劳动 L) &amp; efficiency(劳动效率 E) --&gt; factors(生产要素) -- 生产过程 --&gt; product(产出 Y) --&gt; investment(投资 I) &amp; consumption(消费 C)</code></pre></p><p>首先考虑离散情形。 我们假设每一期生产过程所用时长均为 <spanclass="math inline"><em>h</em></span>。上述所有量首先可以被分为两类：</p><ul><li>存量：<spanclass="math inline"><em>K</em>, <em>L</em>, <em>E</em></span></li><li>流量：<spanclass="math inline"><em>Y</em>, <em>I</em>, <em>C</em></span></li></ul><p>我们认为这些量都是 <span class="math inline"><em>t</em></span>的函数，但是其含义却不尽相同：</p><ul><li>对于存量而言，它的含义是 <span class="math inline"><em>t</em></span>时刻该存量有多少；</li><li>对于流量而言，它的含义是 <spanclass="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内该流量有多少。</li></ul><p>下面考虑连续情形，即 <span class="math inline"><em>h</em> → 0</span>的情形。此时每个生产过程耗费的时间都是无穷小量，故其对应的产出、投资、消费也是无穷小量。为了让这些量仍然具有意义，我们必须修改它们的定义，即将流量修改为该变量在<span class="math inline"><em>t</em></span> 时刻的增长速率。</p><h3 id="生产函数">2.生产函数</h3><h4 id="总生产函数">2.1.总生产函数</h4><p>我们假设生产要素和产出之间存在函数关系，称作总生产函数 <spanclass="math inline"><em>F</em></span>。 具体来说，<spanclass="math inline"><em>F</em></span> 的定义是 <spanclass="math display">$$\begin{align*}    F:\mathbb{R}\times\mathbb{R}&amp;\to\mathbb{R}\\    (K,LE)&amp;\to Y.\end{align*}$$</span> 在离散情形下，<span class="math inline"><em>F</em></span> 将<span class="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了<span class="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内的产出； 在连续情形下，<spanclass="math inline"><em>F</em></span> 将 <spanclass="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了 <spanclass="math inline"><em>t</em></span> 时刻产出的增长速率。</p><p>为了方便研究，我们假设连续情形下 <spanclass="math inline"><em>F</em></span> 是可微的。</p><h4 id="规模报酬不变">2.2.规模报酬不变</h4><p>我们假设总生产函数具有规模报酬不变性质，即如果等比例地增加生产要素，产出也会按相同比例增加。在数学上，这意味着 <span class="math inline"><em>F</em></span>具有齐次性，即对任意的实数 <spanclass="math inline"><em>x</em>, <em>y</em>, <em>λ</em></span> 有 <spanclass="math inline"><em>F</em>(<em>λ</em><em>x</em>,<em>λ</em><em>y</em>) = <em>λ</em><em>F</em>(<em>x</em>,<em>y</em>)</span>。</p><h4 id="总资本边际产量">2.3.总资本边际产量</h4><p>在离散情形下，资本的边际产量 <span class="math inline">MPK</span>是生产要素组合的函数，含义是在该要素组合下，增加一单位资本带来的额外产出，即<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em>(<em>K</em>+1,<em>L</em><em>E</em>) − <em>F</em>(<em>K</em>,<em>L</em><em>E</em>).</span></p><p>很明显，在连续情形下，<span class="math inline">MPK</span> 的定义是<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em><sub>1</sub>(<em>K</em>,<em>L</em><em>E</em>).</span></p><h4 id="人均总生产函数">2.4.人均总生产函数</h4><p>在 Solow模型中，我们十分关注人均情形，但这里的人均情形是有效工人意义下的人均，例如人均资本被定义为总资本比有效工人，即人均资本<span class="math inline">$k:=\frac{K}{LE}$</span>。</p><p>由总生产函数的齐次性，不难得到 <span class="math display">$$y=\frac{Y}{LE}=\frac{1}{LE}F(K,LE)=F\left(\frac{K}{LE},1\right)=F(k,1).$$</span></p><p>但我们并不能就此断言 <span class="math inline"><em>k</em></span> 与<span class="math inline"><em>y</em></span> 之间存在函数关系。 因为<span class="math inline"><em>k</em></span>对应的可能生产要素组合构成了集合 <spanclass="math inline">{(<em>λ</em><em>k</em>,<em>λ</em>)|<em>λ</em> ∈ ℝ}</span>，即该集合中每一种生产要素组合对应的人均资本都是<span class="math inline"><em>k</em></span>。我们必须证明，对集合中的每一种生产要素组合，其对应的人均产量 <spanclass="math inline"><em>y</em></span> 都是相同的，这样 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间才存在函数关系。 否则，若一个<span class="math inline"><em>k</em></span> 对应了多个 <spanclass="math inline"><em>y</em></span>，则两者之间不存在函数关系。</p><p><em>证明：</em> 因为 <span class="math display">$$y=\frac{1}{\lambda}F(\lambda k,\lambda)=F(k,1),$$</span> 所以所有可能生产要素组合的 <spanclass="math inline"><em>y</em></span> 的值都等于 <spanclass="math inline"><em>F</em>(<em>k</em>,1)</span>，因而 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间存在函数关系。</p><p><em>证毕。</em></p><p>不妨将该函数记作 <spanclass="math inline"><em>f</em></span>，称作人均总生产函数，即 <spanclass="math display"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1).</span></p><h4 id="人均资本边际产量">2.5.人均资本边际产量</h4><p>与总生产函数类似，我们也可以为人均总生产函数定义资本边际产量。离散情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>(<em>k</em>+1) − <em>f</em>(<em>k</em>).</span></p><p>连续情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>′(<em>k</em>).</span></p><p>这里就产生了一个问题：人均情形的 <span class="math inline">MPK</span>和总的情形的 <span class="math inline">MPK</span> 的关系是什么。对于离散情形，两者并不存在确切的数量关系。 下面考虑连续情形：</p><blockquote><p>引理：若函数 <span class="math inline"><em>g</em></span> 是 <spanclass="math inline"><em>k</em></span> 阶齐次的，那么它的任一偏导数 <spanclass="math inline">∂<em>g</em>/∂<em>x</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>k</em> − 1</span> 阶齐次的。</p></blockquote><p>因为总生产函数 <span class="math inline"><em>F</em></span>是一阶齐次的（即齐次函数），所以 <spanclass="math inline"><em>F</em></span> 的偏导数 <spanclass="math inline"><em>F</em><sub>1</sub></span>是零阶齐次的，这意味着对任意的实数 <spanclass="math inline"><em>k</em>, <em>λ</em></span> 有 <spanclass="math display">MPK(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>k</em>,1) = <em>f</em>′(<em>k</em>) = MPK(<em>k</em>).</span>由此可以看出，人均资本 <span class="math inline"><em>k</em></span> 的<span class="math inline">MPK</span>，与其对应的各种总的生产要素组合<span class="math inline">(<em>λ</em><em>k</em>,<em>λ</em>)</span> 的<span class="math inline">MPK</span> 是相同的。</p><h3 id="符号表">3.符号表</h3><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">符号</th><th style="text-align: center;">定义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">社会总资本</td><td style="text-align: center;"><spanclass="math inline"><em>K</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均资本</td><td style="text-align: center;"><spanclass="math inline"><em>k</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{K}{LE}$</span></td></tr><tr class="odd"><td style="text-align: center;">社会总劳动</td><td style="text-align: center;"><spanclass="math inline"><em>L</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">社会总产出</td><td style="text-align: center;"><spanclass="math inline"><em>Y</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均产出</td><td style="text-align: center;"><spanclass="math inline"><em>y</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{Y}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总投资</td><td style="text-align: center;"><spanclass="math inline"><em>I</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均投资</td><td style="text-align: center;"><spanclass="math inline"><em>i</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{I}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总消费</td><td style="text-align: center;"><spanclass="math inline"><em>C</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均消费</td><td style="text-align: center;"><spanclass="math inline"><em>c</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{C}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率</td><td style="text-align: center;"><spanclass="math inline"><em>E</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>F</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>f</em></span></td><td style="text-align: center;"><spanclass="math inline"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1)</span></td></tr><tr class="odd"><td style="text-align: center;">储蓄率</td><td style="text-align: center;"><spanclass="math inline"><em>s</em></span></td><td style="text-align: center;">产出中未消费的比例</td></tr><tr class="even"><td style="text-align: center;">折旧率</td><td style="text-align: center;"><spanclass="math inline"><em>δ</em></span></td><td style="text-align: center;">资本损耗的比例</td></tr><tr class="odd"><td style="text-align: center;">劳动力增长率</td><td style="text-align: center;"><spanclass="math inline"><em>n</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaL}{L}$</span> 或 <span class="math inline">$\frac{L'}{L}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率增长率</td><td style="text-align: center;"><spanclass="math inline"><em>g</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaE}{E}$</span> 或 <span class="math inline">$\frac{E'}{E}$</span></td></tr><tr class="odd"><td style="text-align: center;">资本边际产量</td><td style="text-align: center;"><spanclass="math inline">MPK</span></td><td style="text-align: center;"></td></tr></tbody></table><h2 id="二资本增长方程">二、资本增长方程</h2><p>Solow 模型描述了资本的增长规律，本节探讨的资本增长方程是 Solow模型最核心的部分。</p><h3 id="资本的增长过程">1.资本的增长过程</h3><p>如果我们把资本看作单个生产过程的起点，那么整个过程就变为资本的增长过程：<pre><code class=" mermaid">flowchart TB    capital(资本) -- 投入生产 --&gt; factors(生产要素) -- 生产 --&gt; product(产品) --&gt; investment(投资) -- 资本更新 --&gt; capital(资本)</code></pre></p><p>如果我们进一步将资本以外的环节全部抽象成生产过程，资本的增长过程就变为：<pre><code class=" mermaid">flowchart TB    capital(资本) --投入生产--&gt; produce(生产)    produce(生产) --资本更新--&gt; capital(资本)</code></pre></p><p>资本首先作为生产要素进入生产过程。资本在生产过程中资本会有一定的损耗，称作<strong>资本折旧</strong>，这是资本在增长过程中减少的部分。生产出的产品一部分用于消费，另一部分用于<strong>投资</strong>，这是资本在增长过程中增加的部分。Solow模型最核心的思想是，资本净增长等于投资（增加的部分）减去资本折旧（减少的部分），即：<span class="math display">资本增量 = 投资 − 资本折旧.</span></p><p>产出中未消费的比例称作<strong>储蓄率</strong> <spanclass="math inline"><em>s</em></span>，所以每次生产完成后未消费的产出的量是<span class="math inline"><em>s</em><em>Y</em></span>。 根据<ahref="https://en.wikipedia.org/wiki/Saving_identity">储蓄-投资恒等式</a>，未消费的部分即投资，所以投资的量也是<span class="math inline"><em>s</em><em>Y</em></span>。</p><p>资本折旧占资本的比例称作<strong>折旧率</strong> <spanclass="math inline"><em>δ</em></span>，所以每次生产损耗的资本是 <spanclass="math inline"><em>δ</em><em>K</em></span>。</p><h3 id="总资本增长方程">2.总资本增长方程</h3><p>首先考虑离散情形。 用符号代替上面的资本增长方程，就得到： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>Y</em><sub><em>t</em></sub> − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub></span>再用 <spanclass="math inline"><em>Y</em><sub><em>t</em></sub> = <em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>)</span>代入上式，就得到离散情形下的总资本增长方程： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>) − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub>.</span></p><p>连续情形的总资本增长方程同理可得： <span class="math display">$$\frac{dK_t}{dt}=s_tF(K_t,L_tE_t)-\delta_tK_t.$$</span></p><h3 id="人均资本增长方程">3.人均资本增长方程</h3><p>从总资本增长方程出发，我们不难得到人均资本增长方程。</p><p>离散情形的人均资本增长方程： <span class="math display">$$\Delta k_t=\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \Delta k_t    =&amp;\Delta\left(\frac{K_t}{L_tE_t}\right)    =\frac{(\Delta K_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\DeltaE_t]}{(L_{t+1}E_{t+1})(L_tE_t)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\frac{(\DeltaK_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\Delta E_t]}{(L_tE_t)^2}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(代入总资本增长方程)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(由生产函数的齐次性)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t]\\    =&amp;\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程： <span class="math display">$$\frac{dk_t}{dt}=s_tf(k_t)-(\delta_t+n_t+g_t)k_t.$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \frac{dk_t}{dt}    =&amp;\left(\frac{K_t}{L_tE_t}\right)'    =\frac{K'_tL_tE_t-K_t(L'_tE_t+L_tE'_t)}{(L_tE_t)^2}\\    =&amp;\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(代入总资本增长方程)}\\    =&amp;s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(由生产函数的齐次性)}\\    =&amp;s_tf(k_t)-(\delta_t+n_t+g_t)k_t.\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程是 Solow 模型最常见的表述。</p>]]></content>
    
    
    <categories>
      
      <category>经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西方经济学</tag>
      
      <tag>宏观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ机器人搭建教程</title>
    <link href="/2023/02/06/qq-bot-tutorial/"/>
    <url>/2023/02/06/qq-bot-tutorial/</url>
    
    <content type="html"><![CDATA[<p>本文先简要阐述现在流行的QQ机器人的工作原理，再介绍一个机器人搭建案例。</p><p>要编写一个QQ机器人，至少需要实现两种功能：</p><ol type="1"><li>机器人和QQ服务器之间的通信。</li><li>机器人对QQ消息的处理。</li></ol><h2id="一机器人和qq服务器之间的通信">一、机器人和QQ服务器之间的通信</h2><p>机器人和QQ服务器之间有以下几种通信方式。</p><h3 id="通信方式1直接通信">1.通信方式1：直接通信</h3><!-- > 通信方式1：【QQ服务器】---QQ协议---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(机器人)</code></pre><p>QQ客户端与服务端之间依赖于一套特定协议来通信，暂且称作<strong>QQ协议</strong>。如果我们知道了协议的具体内容，就可以伪装成QQ客户端，按这套协议直接向服务端发送信息，并且按这套协议解析服务端发来的信息。</p><p>但该做法存在以下几个问题：</p><ul><li>逆向工程。QQ的协议由腾讯公司私有，我们并不知道其具体内容。所以我们需要对QQ客户端进行逆向工程，但这个工作相当复杂。</li><li>网络编程。为了发送QQ消息，我们需要编写相应代码来封装、发送QQ消息；为了接收QQ消息，我们也需要编写相应代码来接收、解析QQ消息。</li></ul><p>但是在编写机器人时，我们最应该关心的是机器人处理QQ消息的逻辑，而不是这些底层且复杂的工作。</p><h3 id="通信方式2通过中介进行通信">2.通信方式2：通过中介进行通信</h3><!-- > 通信方式2：【QQ服务器】---QQ协议---【中介】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中介)-- 库调用 ---id3(机器人)</code></pre><p>为了解决上述两个问题，我们可以编写一个<strong>中介</strong>。一方面，中介与QQ服务器进行具体的通信；另一方面，中介为我们提供简单易用的<strong>库接口</strong>。在编写机器人时，我们只需要直接调用这些库接口，让中介去进行具体的通信工作。这样，逆向工程和网络编程就由编写中介的程序员完成；而编写机器人的程序员不再需要操心这些底层问题，只需了解库接口如何调用。</p><p>这种通信方式依然存在一个问题：通常来说，编写机器人和编写中介的语言应该是相同的。例如，我们使用的是实现为Java库的中介，那么我们只能使用Java语言来调用中介的接口。于是，编写机器人的语言种类受到了限制。</p><h3id="通信方式3通过中介和适配器进行通信">3.通信方式3：通过中介和适配器进行通信</h3><!-- > 通信方式3：【QQ服务器】---QQ协议---【中介】---中介协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中介)-- 中介协议 ---id3(适配器)-- 库调用 ---id4(机器人)</code></pre><p>为了让各种语言都可以使用同一个中介，我们可以将中介实现为独立运行的软件，提供<strong>通用的本地网络接口</strong>（例如：HTTP，Websocket，ReverseWebsocket），制订一套简单的中介接口协议。这样，不管我们使用什么编程语言，只要按协议调用这些接口，就可以使用中介的功能。</p><p>但提升中介通用性带来的代价是，我们又要面对网络编程这个麻烦事（机器人和中介之间通过本地网络通信）。为了回避网络编程，我们可以为每种编程语言开发相应的<strong>适配器</strong>（实现为库），只需调用适配器提供的库接口，让适配器与中介进行沟通。</p><blockquote><p>这种通信方式的确比前一种更加迂回。如果我们为每一种编程语言开发相应的中介库而非适配器，就可以避免迂回。之所以不这么做，是因为开发中介的工作量要大于开发适配器，提高中介的通用性更加划算。</p></blockquote><h3 id="推荐的中介mirai">4.推荐的中介：Mirai</h3><p>常见的中介有 Mirai，酷Q，oicq 等等。 本文推荐 <ahref="https://github.com/mamoe/mirai">Mirai</a> 的理由有：</p><ol type="1"><li>全平台通用。Mirai 由 Kotlin 语言编写，可以运行在Windows，Linux，MacOS 等操作系统上。</li><li>小巧。我电脑上的 mirai-console 只有 60 多 M。</li><li>开源。</li></ol><p>Mirai 本身是一个库，也就是说我们需要使用 Kotlin编写机器人，按照上述的<em>通信方式2</em>与QQ服务器进行通信。</p><p>但 Mirai 官方也将 Mirai 实现为了一个独立运行的程序，名为 <ahref="https://github.com/mamoe/mirai/tree/dev/mirai-console">mirai-console</a>。mirai-console 中安装了 mirai-api-http 插件后，就可以提供本地网络接口。于是我们可以使用任何编程语言，按照上述的<em>通信方式3</em>与QQ服务器进行通信。</p><h3 id="其他聊天软件">5.其他聊天软件</h3><p>上述通信方式并不局限于和QQ服务器的通信。如果我们要编写其他聊天软件的机器人，通信方式也是类似的。有些聊天软件还提供公开的接口，例如钉钉、Discord。为这些软件编写机器人时，我们就不需要中介的帮助了。例如钉钉机器人的通信方式是：<!-- > 通信方式（钉钉）：【钉钉服务器】---DingTalk协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(钉钉服务器)-- DingTalk协议 ---id2(适配器)-- 库调用 ---id3(机器人)</code></pre></p><h2 id="二机器人框架">二、机器人框架</h2><p>机器人不管为何种聊天软件编写，都具有一些类似的特点：</p><ul><li>消息驱动。通常来说，机器人是被动地处理消息，接收到特定命令时完成特定功能。</li><li>插件系统。通常机器人提供的功能不止一种。为了方便编程，我们可以将各种功能抽象为插件，实现一个插件管理系统，根据接收到的命令运行特定插件。</li><li>异步编程。要让机器人可以同时处理多个命令，需要用到异步编程。</li><li>……</li></ul><p>于是，我们可以进一步抽象出一个具有上述功能的机器人框架。它不但可以帮助我们更简单地编写一个机器人，还可以让我们的机器人具有跨聊天平台的特性。</p><p>机器人框架的种类十分丰富。选取哪一个机器人框架，取决于我们选用的语言、中介。</p><h2 id="三机器人搭建方案">三、机器人搭建方案</h2><p>要搭建一个机器人，我们需要决定三件事：</p><ol type="1"><li>选取什么中介。</li><li>选取什么编程语言。</li><li>选取什么机器人框架。</li></ol><blockquote><p>适配器通常包含于机器人框架内，不需要选取。</p></blockquote><p>下面提供了几种选取方案：</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: center;">中介</th><th style="text-align: center;">编程语言</th><th style="text-align: center;">通信方式</th><th style="text-align: center;">机器人框架</th><th style="text-align: center;">mirai-console</th><th style="text-align: center;">mirai-api-http</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">✅</td><td style="text-align: center;">❌</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/iTXTech/mirai-kts">Mirai Kts</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">C++</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/cyanray/mirai-cpp">mirai-cpp</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://v2.nonebot.dev/">NoneBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://docs.alicebot.dev/">AliceBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr></tbody></table><p>更多机器人框架可以参见 <ahref="https://docs.mirai.mamoe.net/#http-%E6%8E%A5%E5%8F%A3">mirai开发文档（HTTP 接口）</a>。 方案1是将 Mirai 作为库来调用，所以不需要mirai-console 和 mirai-api-http ； 方案2是将机器人写成 mirai-console的插件，被它调用，所以需要 mirai-console。</p><p>有关 Mirai 生态的更多内容，参见 <ahref="https://docs.mirai.mamoe.net/mirai-ecology.html">mirai开发文档（生态简介）</a>。</p><h2 id="四案例miraialicebot-环境搭建">四、案例：Mirai+AliceBot环境搭建</h2><p>下面详细介绍方案6的环境搭建。<!-- > 通信方式：【QQ服务器】---QQ协议---【Mirai】---Mirai API---【AliceBot适配器】---库调用---【AliceBot】 --></p><p>方案6的通信方式： <pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(Mirai)-- Mirai API ---id3(AliceBot适配器)-- 库调用 ---id4(AliceBot)</code></pre></p><p>安装清单：</p><ol type="1"><li>JRE：Java 运行时。Mirai 基于 Kotlin 开发，需要 JRE 环境。</li><li>mirai-console：独立运行的中介。</li><li>mirai-api-http：提供本地网络接口的中介插件。</li><li>alicebot：机器人框架。</li><li>alicebot-adapter-mirai：与 alicebot 配套的 mirai 适配器。</li></ol><h3 id="安装-mirai">1.安装 Mirai</h3><p>我们可以使用 Mirai 官方提供的<ahref="https://github.com/iTXTech/mcl-installer/releases">自动安装器</a>来安装mirai-console。 如果计算机上没有 JRE，自动安装器也可以帮助安装。 &gt;mirai-console 有两个版本，一个有 GUI 界面，一个没有，详情参见 <ahref="https://github.com/mamoe/mirai/blob/dev/docs/UserManual.md">Mirai用户手册</a>。自动安装器安装的是无 GUI 界面版本。</p><p>mirai-console 安装完成后，安装目录中会出现名为 mcl(Mirai ConsoleLoader) 的脚本。 运行此脚本即可启动 mirai-console。</p><p>安装 mirai-api-http 插件可以利用 mirai-console 命令：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl --update-package net.mamoe:mirai-api-http --channel stable --<span class="hljs-built_in">type</span> plugin<br></code></pre></td></tr></table></figure></p><h3 id="初步配置-mirai">2.初步配置 Mirai</h3><p>运行 mcl 脚本来启动 mirai-console： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl<br></code></pre></td></tr></table></figure></p><p>mirai-console 成功启动后，可以输入 <code>/help</code>查看帮助文档。</p><p>登录 QQ 账号的命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/login &lt;qq&gt; [password] [protocol]<br></code></pre></td></tr></table></figure></p><p>设置自动登录： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autoLogin add &lt;account&gt; &lt;password&gt;<br></code></pre></td></tr></table></figure></p><p>退出 mirai-console： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/stop<br></code></pre></td></tr></table></figure></p><p>mirai-console 支持的登录协议有<code>ANDROID_PHONE</code>、<code>ANDROID_PAD</code>、<code>ANDROID_WATCH</code>、<code>MACOS</code>、<code>IPAD</code>五种。 QQ服务器通过登录协议来识别登录设备的种类。 mirai-console 默认使用<code>ANDROID_PHONE</code> 协议登录，因此 mirai 会将自身伪装成安卓手机。如果想要让手机和 mirai-console同时登录一个账号，我们可以将登录协议切换为<code>ANDROID_PAD</code>，因为QQ允许安卓手机和平板同时登陆。切换自动登录使用的协议： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autologin setConfig &lt;account&gt; protocol &lt;protocol&gt;<br></code></pre></td></tr></table></figure></p><h3 id="mirai-console-目录结构">3.mirai-console 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Directory">.<br>├── config<br>│   ├── Console<br>│   │   ├── AutoLogin.yml<br>│   │   └── ...<br>│   └── net.mamoe.mirai-api-http<br>│       └── setting.yml<br>├── plugins<br>└── ...<br></code></pre></td></tr></table></figure><ul><li><code>./config/Console/AutoLogin.yml</code>文件包含自动登录的相关配置。</li><li><code>./config/net.mamoe.mirai-api-http/setting.yml</code> 文件包含mirai-api-http 插件的相关配置。安装该插件并运行 mirai-console之后才会生成此文件。</li><li><code>./plugins</code> 文件夹用于存放 mirai-console插件。mirai-console 启动后会自动加载该文件夹中的插件。</li></ul><blockquote><p>mirai-console 的插件可以在 <ahref="https://mirai.mamoe.net/category/11/%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83">Mirai论坛</a> 下载。</p></blockquote><h3 id="安装-alicebot">4.安装 AliceBot</h3><p>使用 pip 安装即可。 安装 alicebot： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot<br></code></pre></td></tr></table></figure> 安装alicebot-adapter-mirai： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot-adapter-mirai<br></code></pre></td></tr></table></figure> ### 5.配置 AliceBot 在配置AliceBot 之前建议先了解其<ahref="https://docs.alicebot.dev/guide/index.html">工作原理</a>。AliceBot 是 Python 库，并非独立运行的软件，我们需要编写 Python脚本并调用 AliceBot 库来实现一个机器人。 可以参照其<ahref="https://docs.alicebot.dev/guide/getting-started.html">开发文档（快速上手）</a>编写一个简单的AliceBot 项目。</p><p>要让 AliceBot 正常工作，必须先对 AliceBot 和 Mirai进行配置，让它们能够正确地通信，详细配置方式参照其<ahref="https://docs.alicebot.dev/guide/basic-config.html">开发文档（基本配置）</a>和<ahref="https://docs.alicebot.dev/guide/mirai-adapter.html">开发文档（Mirai协议适配器）</a>。 配置的关键之处在于让 AliceBot 和 Mirai选择同一套网络协议，并且使用相同的 <code>verify_key</code>。</p><h3 id="运行">6.运行</h3><p>mirai-console 和 AliceBot机器人脚本是两个独立的程序，它们之间通过本地网络接口通信。因此，在运行机器人时，我们必须同时运行两个程序。至于两个程序的存放路径则是无关紧要的，我们可以把它们放在同一目录下，也可以不这么做。我们可以将自己或他人编写的 AliceBot插件放在指定的插件目录下，它就会自动运行该插件。 AliceBot插件的编写方式参考<ahref="https://docs.alicebot.dev/guide/plugin-basics.html">开发文档(插件基础)</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
