<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IO 模型</title>
    <link href="/io-model/"/>
    <url>/io-model/</url>
    
    <content type="html"><![CDATA[<h1 id="io-模型">IO 模型</h1><p>在各类现代操作系统中，有五种常见的 IO 模型：</p><table><thead><tr class="header"><th>英文名</th><th>中文名</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>Blocking IO</td><td>阻塞 IO</td><td>IO 执行模型</td></tr><tr class="even"><td>Non-blocking IO</td><td>非阻塞 IO</td><td>IO 执行模型</td></tr><tr class="odd"><td>IO multiplexing</td><td>IO 多路复用</td><td>IO 事件模型</td></tr><tr class="even"><td>Signal-driven IO</td><td>信号驱动 IO</td><td>IO 事件模型</td></tr><tr class="odd"><td>Asynchronous IO</td><td>异步 IO</td><td>IO 执行模型</td></tr></tbody></table><p>这里的类型是我起的名字。 之所以进行这样一种分类，是因为阻塞IO、非阻塞 IO、异步 IO 会实际地读写数据，而 IO 多路复用与信号驱动 IO并不读写数据，只负责通知 IO 事件。 下面具体介绍五种模型：</p><h2 id="阻塞-io-与非阻塞-io">阻塞 IO 与非阻塞 IO</h2><p>阻塞 IO 与非阻塞 IO 的主要区别是:</p><ul><li>阻塞 IO：调用 IO操作时，如果数据没准备好，调用会一直等待，直到完成才返回。</li><li>非阻塞 IO：调用 IO操作时，如果数据没准备好，调用会立即返回并告知用户程序，不会阻塞程序执行。</li></ul><p>在 Linux 中，无论阻塞 IO 还是非阻塞IO，都使用相同的系统调用读写文件。 而具体是哪一种 IO 模式，主要是由<code>&lt;fs.h&gt;</code> 中的结构体 <code>file</code> 的<code>f_flags</code> 字段决定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    ...<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> f_flags;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>f_flags</code> 是一个位掩码字段，每一个标志位分别表示一个状态。常用的标志位有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 访问模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_RDONLY00000000    <span class="hljs-comment">// 只读模式</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_WRONLY00000001    <span class="hljs-comment">// 只写模式</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_RDWR00000002    <span class="hljs-comment">// 读写模式</span></span><br><br><span class="hljs-comment">// 文件状态标志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_NONBLOCK  00004000    <span class="hljs-comment">// 非阻塞 IO</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_ASYNC00020000    <span class="hljs-comment">// 信号驱动 IO</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_DIRECT00040000    <span class="hljs-comment">// 直接 IO</span></span><br></code></pre></td></tr></table></figure><p>其中，<code>O_NONBLOCK</code> 关闭则代表阻塞 IO模式，开启则代表非阻塞 IO 模式。如果要同时表示多种状态，可以用位或运算拼接。 例如只读 + 非阻塞 IO可以表示为 <code>O_RDONLY | O_NONBLOCK</code>。</p><p>要启用非阻塞 IO 模式，本质上就是让文件描述符对应的<code>file-&gt;f_flags</code> 中的 <code>O_NONBLOCK</code> 开启。这主要有以下几种方式：</p><ol type="1"><li>在打开文件时就指定模式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;file.txt&quot;</span>, O_RDONLY | O_NONBLOCK);<br></code></pre></td></tr></table></figure></li><li>打开文件后使用 <code>fcntl</code> 设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> flags = fcntl(fd, F_GETFL, <span class="hljs-number">0</span>);      <span class="hljs-comment">// 获取当前标志</span><br>fcntl(fd, F_SETFL, flags | O_NONBLOCK); <span class="hljs-comment">// 设置非阻塞</span><br></code></pre></td></tr></table></figure></li><li>对 socket 使用 <code>ioctl</code>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> flags = <span class="hljs-number">1</span>; <span class="hljs-comment">// 1 表示开启非阻塞</span><br>ioctl(fd, FIONBIO, &amp;flags); <br></code></pre></td></tr></table></figure></li></ol><h2 id="io-多路复用">IO 多路复用</h2><p>IO多路复用的核心理念，是由操作系统提供一套机制，方便单个线程同时监听多个IO 事件。</p><!-- | 操作系统 | 实现 || --- | --- || Linux | select, poll, epoll || Windows | selec, IOCP || MacOS | ... | --><p>在不同的操作系统下，IO 多路复用有不同的具体实现。 Linux 本身就提供了select、poll、epoll 三种 IO 多路复用方案。 不论具体的实现如何，IO多路复用总是由以下两个部分组成：</p><p><strong>第一部分：监听的文件集合</strong></p><p>要使用 IO 多路复用，操作系统必须知道需要监听哪些文件的哪些 IO 事件。Linux 的三种 IO 多路复用方案分别使用了不同的方式来管理监听对象：</p><ol type="1"><li>select 使用位图 <code>fd_set</code> 存储监听对象。<code>fd_set</code> 包含一个 <code>unsigned long[]</code>数组，其中每个位对应一个文件描述符，容量默认为 1024。 如果 fd被加入集合，对应位为 1，否则为 0。 调用 <code>select</code>时，<code>fd_set</code> 作为参数传递给内核。 select的缺点是位图大小有上限，最多只能监听 1024 个文件。</li><li>poll 使用数组 <code>pollfd</code> 替代<code>fd_set</code>，每个元素包含 fd + 关心的事件类型。 调用<code>poll</code> 时，<code>pollfd</code> 作为参数传递给内核。 poll相较于 select，不再有监听数量的上限。</li><li>epoll 使用红黑树 <code>struct rb_root_cached rbr</code>来存储监听对象。 红黑树每个节点的类型是<code>struct epitem</code>，存储了监听的 fd 和事件类型。用户程序不直接操作红黑树，而是通过系统调用 <code>epoll_ctl</code>注册文件。</li></ol><p><strong>第二部分：事件通知机制</strong></p><p>事件通知机制是指：内核如何告诉用户程序某个文件的发生了某个 IO 事件。Linux 的三种 IO 多路复用方案的事件通知机制如下：</p><ol type="1"><li>select 的核心机制是轮询，会扫描每个 fd 看是否就绪，并将就绪 fd对应的位设置回 <code>fd_set</code>，最后返回就绪文件的数量。 select可以设置为阻塞、超时阻塞、非阻塞三种模式。</li><li>poll 的核心机制和 select 一致，主要区别在于数据结构的不同。其轮询过程是遍历数组，检查每个 fd 是否就绪。</li><li>epoll 的核心机制是内核维护就绪链表 + 回调通知。 用户程序调用<code>epoll_wait()</code> 等待事件。 当 fd 就绪时，内核通过回调直接将<code>epitem</code> 放入就绪链表，再将事件写入用户态数组<code>events</code>，最后返回就绪文件数量。 epoll采用的是真正的事件驱动模型。</li></ol><p>IO 多路复用是一种监听 IO 事件的模型，本身不提供读写文件的能力。通常来说，用户在获知了可读可写的事件集合之后，再去读写相应的文件。由于文件已经就绪，用户程序不会再长时间阻塞，由此提高了效率。</p><p>所以 IO 多路复用与前面所说的阻塞 IO 和非阻塞 IO并不是同一层级的概念，后两者是读写方式的区别。 通常来说，IO多路复用要与非阻塞 IO 搭配使用。 如果使用阻塞IO，程序仍然可能由于一些原因被阻塞。例如，文件内容被其他线程读取，或者读取的长度超过了就绪数据的长度，等等。如果线程被阻塞，就违背了使用 IO 多路复用的初衷。</p><p>不过，Linux 并不禁止 IO 多路复用与阻塞 IO搭配使用，但这没有什么意义，只会降低效率。 并且在较新版本的 Java NIO中，已经禁止这一搭配。</p><h2 id="信号驱动-io">信号驱动 IO</h2><p>信号驱动 IO的核心机制，是通过操作系统发送信号来通知程序数据已就绪。</p><p>在 Linux 中开启信号驱动 IO，需要将 <code>f_flags</code> 的标志位<code>O_ASYNC</code> 设置为开启状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> flags = fcntl(fd, F_GETFL, <span class="hljs-number">0</span>);                  <span class="hljs-comment">// 获取当前标志</span><br>fcntl(fd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);   <span class="hljs-comment">// 设置信号驱动与非阻塞</span><br></code></pre></td></tr></table></figure><p>如果数据就绪，操作系统会发送 <code>SIGIO</code> 信号。通常还需要将文件设置为非阻塞 IO模式，这是因为信号处理函数是在异步上下文执行的。 如果是阻塞IO，信号处理函数可能会被阻塞，导致线程无法正常运行。</p><p>可以看出，信号驱动 IO 和 IO多路复用是同一层级的概念，它们存在的目的都是为了监听 IO事件，避免低效率的阻塞。 不过，信号驱动 IO一般不会被使用，这主要是因为程序运行的流程很难控制。</p><h2 id="异步-io">异步 IO</h2><p>在讨论 IO 多路复用的时候，我们曾经说过 IO 多路复用通常要与非阻塞 IO搭配使用，这是因为 IO 多路复用只是一个 IO事件通知模型，并不负责数据的读写。用户程序减少了无效的阻塞时间，但频繁的读写操作仍然伴随着大量的上下文切换，这是一个较大的性能瓶颈。</p><p>异步 IO 的核心思想则是则是尽可能减少上下文切换的次数：</p><ul><li>非阻塞提交：用户态可以直接提交 IO请求，不需要切换为内核态，不阻塞等待。</li><li>内核直接操作用户缓冲区：IO完成后数据可以直接写入用户态内存，而无需经过额外拷贝。</li><li>异步通知：在完成时通过最小开销的通知（一般是事件队列）处理结果。</li></ul><p>Linux 下对异步 IO 有三种实现：</p><ol type="1"><li>native AIO（io_submit 与 libaio）。 io_submit 是 Linux内核提供的异步 IO 系统调用，libaio 是对其进行封装的用户态库。 native AIO最初是为块设备设计的，而对普通文件基本不支持真正异步。</li><li>glibc 对 POSIX AIO 的实现。 其底层本质上依然是调用 native AIO 接口。如果内核不支持 native AIO，则退化为线程池模拟异步 IO。</li><li>io_uring 与 liburing。 io_uring 是目前 Linux 中最强大的异步 IO接口。它的主要工作原理是提供了两个环形缓冲区：一个是提交队列，另一个是完成队列。用户程序将 IO 请求写入提交队列，从完成队列读取 IO 结果；内核从提交队列读取 IO 请求并处理，将结果写入完成队列。内核与用户程序共享这两个队列，避免了频繁的系统调用，大大减少了上下文切换的成本。</li></ol><p>关于 io_uring，参见<a href="/io-uring/">下一篇文章</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发雪花算法</title>
    <link href="/2025/11/15/concurrent-snowflake/"/>
    <url>/2025/11/15/concurrent-snowflake/</url>
    
    <content type="html"><![CDATA[<h1 id="并发雪花算法">并发雪花算法</h1><p>网上已经有很多雪花算法（Snowflake）的实现教程，但是这些教程大多没有考虑单机的并发带来的竞态条件，或者直接给整个方法加<code>synchronzied</code>，使方法的运行串行化，大大降低了并发性能。本文试图实现一个高并发性能的雪花算法。</p><p>雪花算法所需的基本常量如下：</p><table><thead><tr class="header"><th>常量名</th><th>含义</th><th>类型</th><th>值</th></tr></thead><tbody><tr class="odd"><td><code>TIMESTAMP_BITS</code></td><td>时间戳位数</td><td><code>int</code></td><td><code>41</code></td></tr><tr class="even"><td><code>WORKER_ID_BITS</code></td><td>Woker ID 位数</td><td><code>int</code></td><td><code>10</code></td></tr><tr class="odd"><td><code>SEQUENCE_BITS</code></td><td>序列号位数</td><td><code>int</code></td><td><code>12</code></td></tr><tr class="even"><td><code>EPOCH</code></td><td>初始时间</td><td><code>long</code></td><td></td></tr><tr class="odd"><td><code>CLOCK_BACKWARD_TOLERANCE</code></td><td>时钟回拨容忍度</td><td><code>long</code></td><td></td></tr></tbody></table><h2 id="基于-cas-的雪花算法">基于 CAS 的雪花算法</h2><p>雪花算法中存在竞态条件的共享资源主要是两个： 上次生成 id 时的时间戳<code>lastTimestamp</code> 和序列号 <code>sequence</code>。因此一个显而易见的想法，就是构建状态对象来保存这两个属性，并利用原子引用<code>AtomicReference</code> 实现状态变更操作的原子化。</p><p>基于 CAS 的雪花算法的主要流程如下：</p><ol type="1"><li>其核心是对 <code>State</code> 对象的原子引用<code>globalState</code>，它描述了系统上次生成 id 时的时间戳<code>lastTimestamp</code> 和序列号 <code>sequence</code>。</li><li>每次生成新 id 时，<code>generate</code> 方法都会获取<code>globalState</code>引用的状态对象，将当前时间戳和上次时间戳进行比较，根据不同的情形选择不同的行为。</li><li>如果<code>currentTimeStamp &lt; lastTimestamp</code>，说明发生了时间回拨。如果回拨在容忍值范围内，则直接将当前时间戳调整为上次时间戳，然后继续方法；如果超过容忍值则报错。</li><li>如果<code>currentTimeStamp == lastTimestamp</code>，说明仍处于同一微秒，此时将<code>sequence</code> 加 1。 如果 <code>sequence</code>已经超过了上限，则等待进入下一微秒。</li><li>如果<code>currentTimeStamp &gt; lastTimestamp</code>，说明已进入了新的微秒，此时重置<code>sequence</code> 为 0。</li><li>根据 <code>currentTimeStamp</code> 和 <code>sequence</code>生成新的状态对象，以 CAS 的方式赋值给 <code>globalState</code>。如果有两个线程同时要更新 <code>globalState</code>，由于更新操作是CAS，只会有一个线程成功，另一个线程重新上述流程，直至成功。</li></ol><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CASSnowflake</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Snowflake</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SEQUENCE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1L</span> &lt;&lt; SEQUENCE_BITS) - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WORKER_ID_LEFT_SHIFT</span> <span class="hljs-operator">=</span> SEQUENCE_BITS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIMESTAMP_LEFT_SHIFT</span> <span class="hljs-operator">=</span> SEQUENCE_BITS + WORKER_ID_BITS;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">State</span><span class="hljs-params">(<span class="hljs-type">long</span> timestamp, <span class="hljs-type">long</span> sequence)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 全局状态，保证原子性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;State&gt; globalState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(-<span class="hljs-number">1L</span>, <span class="hljs-number">0L</span>));<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">State</span> <span class="hljs-variable">lastState</span> <span class="hljs-operator">=</span> globalState.get();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">lastTimestamp</span> <span class="hljs-operator">=</span> lastState.timestamp;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">currentTimestamp</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> lastState.sequence;<br><br>            <span class="hljs-comment">// 若当前时间戳小于上次时间戳，说明发生了时间回拨</span><br>            <span class="hljs-keyword">if</span> (currentTimestamp &lt; lastTimestamp) &#123;<br>                checkTimeBackwardTolerance(currentTimestamp, lastTimestamp);<br>                <span class="hljs-comment">// 若时间回拨能够容忍，则直接从上次时间戳开始生成 id</span><br>                currentTimestamp = lastTimestamp;<br>            &#125;<br><br>            <span class="hljs-comment">// 当前时间戳等于上次时间戳，递增序列号</span><br>            <span class="hljs-keyword">if</span> (currentTimestamp == lastTimestamp) &#123;<br>                sequence = (sequence + <span class="hljs-number">1</span>) &amp; SEQUENCE_MASK;<br><br>                <span class="hljs-comment">// 序列号达到上限，等待进入下一微秒</span><br>                <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        Thread.onSpinWait();<br>                        currentTimestamp = System.currentTimeMillis();<br>                        checkTimeBackwardTolerance(currentTimestamp, lastTimestamp);<br>                    &#125; <span class="hljs-keyword">while</span> (currentTimestamp &lt;= lastTimestamp);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当前时间戳大于上次时间戳，重置序列号</span><br>                sequence = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 生成新状态</span><br>            <span class="hljs-type">State</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(currentTimestamp, sequence);<br><br>            <span class="hljs-comment">// CAS 状态</span><br>            <span class="hljs-keyword">if</span> (globalState.compareAndSet(lastState, newState)) &#123;<br>                <span class="hljs-comment">// 成功，返回id</span><br>                <span class="hljs-keyword">return</span> ((currentTimestamp - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT) |<br>                        (workerId &lt;&lt; WORKER_ID_LEFT_SHIFT) |<br>                        sequence;<br>            &#125;<br><br>            <span class="hljs-comment">// 失败，进行下一次尝试</span><br>            Thread.onSpinWait();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查时间回拨是否超出容忍值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkTimeBackwardTolerance</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTimestamp, <span class="hljs-type">long</span> lastTimestamp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentTimestamp + CLOCK_BACKWARD_TOLERANCE &lt; lastTimestamp) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;时间回拨超出容忍值&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>Thread.onSpinWait()</code> 方法不做任何逻辑，其作用是告知JVM 和 CPU 线程正处于自旋等待，以便做一些底层优化。</p><p>相较于直接给整个方法加 <code>synchronized</code> 的方案而言，基于 CAS的明显优点是提高了并发能力。 但其缺点也是明显的：在并发度较高的时候，会出现多个线程自旋等待。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短链服务（数据统计篇）</title>
    <link href="/shorto/statistics/"/>
    <url>/shorto/statistics/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务数据统计篇">短链服务（数据统计篇）</h1><p>短链服务除了生成和解析功能外，还应提供统计分析能力，例如：</p><ol type="1"><li>PV、UV、来源统计；</li><li>地理位置与设备分布；</li><li>日志采集与异常监控。</li></ol><p>解析模块和统计模块之间通过消息队列传递日志，可以很好地解耦模块，削峰填谷。中间件使用 Kafka。</p><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短链服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短链服务（后台管理篇）</title>
    <link href="/shorto/backend/"/>
    <url>/shorto/backend/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务后台管理篇">短链服务（后台管理篇）</h1><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短链服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短链服务（短链解析篇）</title>
    <link href="/shorto/resolve/"/>
    <url>/shorto/resolve/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务短链解析篇">短链服务（短链解析篇）</h1><p>短链解析模块承担核心任务：根据短链码查找原始 URL。在最初级的实现中，我们可以直接通过一条数据库查询实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLongUrl</span><span class="hljs-params">(String shortCode)</span> &#123;<br>    <span class="hljs-comment">// 查询数据库</span><br>    <span class="hljs-type">UrlMap</span> <span class="hljs-variable">urlMap</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;short_code&quot;</span>, shortCode).one();<br>    <span class="hljs-keyword">if</span> (urlMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果不存在，返回 null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    longUrl = urlMap.getLongUrl();<br>    <br>    <span class="hljs-keyword">return</span> longUrl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这虽然功能完备，但当请求量上升时，数据库很快会成为性能瓶颈。因此，我们需要引入缓存层（Redis）来加速查询。通常短链服务的读写比例极不平衡，读操作远多于写操作。使用缓存后，我们可以将热点短链的映射直接存放在 Redis中，大幅提升性能。</p><h2 id="多级缓存的问题">多级缓存的问题</h2><p>但是缓存可能出现以下几个问题：</p><h3 id="问题-1缓存穿透">问题 1：缓存穿透</h3><p>缓存穿透是指用户请求的数据在缓存和数据库中都不存在，每次请求都会打到数据库上，造成压力。我们可以考虑如下几个方案：</p><ol type="1"><li>对短链码合法性进行初步校验。</li><li>对于查询不到的短链，在 Redis中缓存一个“空值”一段时间，避免反复访问数据库。</li></ol><p>但是这个场景不太适合使用 Bloom 过滤器。</p><h3 id="问题-2缓存击穿">问题 2：缓存击穿</h3><p>缓存击穿是指<strong>高并发访问</strong>且<strong>缓存重建业务较复杂</strong>的热点key 失效，无数的请求瞬间给数据库带来巨大的冲击。对于我们的服务而言，重建 key 只涉及一次数据库查询和一次 Redis写请求，比较简单，所以缓存击穿的风险不高。</p><h3 id="问题-3缓存雪崩">问题 3：缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis服务宕机，导致大量请求到达数据库，带来巨大压力。对于我们的短链解析服务而言，缓存 key的过期时间更可能是随机的，因此主要需要关注 Redis 服务宕机的问题。可以考虑如下几个方案：</p><ol type="1"><li>使用 Redis 集群提高可用性。</li><li>添加限流策略。</li><li>使用多级缓存。</li></ol><p>我们在这里使用 Caffeine 提供的本地缓存。使用方法也十分简便，只需要给函数体添加 <code>@Cacheable</code>注解。</p><h2 id="定时清理过期短链">定时清理过期短链</h2><p>为了实现定时清理功能，我们需要给映射表添加一个<code>(status, expire_time)</code>的联合索引，这样可以利用最左匹配原则。数据库中可能有大量过期短链，这样可以首先排除 <code>status = 0</code>即过期的短链。 如果我们建立的是 <code>(expire_time, status)</code>索引，由于第一个字段的查询是范围查询，就没法充分利用最左匹配原则。</p><p>为了避免多个实例重复运行清理任务，还需要加一个分布式锁，考虑使用Redisson。</p><h2 id="响应式">响应式</h2><p>上述短链解析过程中，如果能够在本地缓存查到映射，则可以直接返回结果。但如果要进行 Redis 或 MySQL 查询，则线程会阻塞住，降低吞吐能力。因此可以考虑响应式编程，使用 Spring WebFlux + Netty，在线程发送 IO请求后，直接切换到下一个请求进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短链服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短链服务（短链生成篇）</title>
    <link href="/shorto/generator/"/>
    <url>/shorto/generator/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务短链生成篇">短链服务（短链生成篇）</h1><h2 id="方案-1长链哈希-截断-冲突处理">方案 1：长链哈希 + 截断 +冲突处理</h2><p>对长链做哈希（MD5、SHA256），取前 N 位作为短链。</p><ul><li>优点：无需自增 ID，可批量离线生成，输入相同 URL可得到相同短链。</li><li>缺点：哈希冲突不可避免，需查询数据库或缓存判断短链是否存在，安全性较低。</li></ul><h2 id="方案-2数据库自增-id-base-62-编码">方案 2：数据库自增 ID + Base62 编码</h2><p>这是最容易想到的一种算法，也是本项目所使用的方案。 思路大致如下：</p><ol type="1"><li>数据库维护一个自增 ID。</li><li>每生成一个短链，就从数据库拿到一个新的 ID。</li><li>将 ID 编码为 62 进制（数字 + 大写字母 + 小写字母）得到短链。</li></ol><p>这个方案的优点是：</p><ol type="1"><li>数据库实现容易。</li><li>天然保证唯一性。</li></ol><p>可是这个方案的缺点也很明显：</p><ol type="1"><li>短链可被预测。</li><li>单点数据库生成 ID 可能成为瓶颈。</li></ol><h2 id="方案-3号段-线性混淆-base62-编码">方案 3：号段 + 线性混淆 +Base62 编码</h2><p>这个方案基于方案 2。 为了解决方案 2的两个问题，我们可以用号段方案降低单点压力，并且使用轻量级的线性混淆。</p><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;autoIncrementShortCodeGenerator&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoIncrementShortCodeGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShortCodeGenerator</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ISegmentGenerator segmentGenerator;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SEGMENT_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MULTIPLIER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1580030173L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">59260789L</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.获取新 id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> current.getAndIncrement();<br><br>        <span class="hljs-comment">// 2.如果 id 达到最大值，申请新号段</span><br>        <span class="hljs-keyword">if</span> (id &gt;= maxId) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">if</span> (current.get() &gt;= maxId) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">newMax</span> <span class="hljs-operator">=</span> segmentGenerator.nextSegment(SEGMENT_SIZE);<br>                    current.set(newMax - SEGMENT_SIZE);<br>                    maxId = newMax;<br>                &#125;<br>                id = current.getAndIncrement();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3.线性混淆</span><br>        id = (id * MULTIPLIER + INCREMENT) % MOD;<br><br>        <span class="hljs-comment">// 4.Base62 编码</span><br>        <span class="hljs-keyword">return</span> Base62Encoder.encode(id);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>SegmentGenerator</code> 的 <code>nextSegment</code>方法基于事务实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> segment_generator <span class="hljs-keyword">SET</span> max_id <span class="hljs-operator">=</span> max_id <span class="hljs-operator">+</span> #&#123;segmentSize&#125; <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;short_code&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> max_id <span class="hljs-keyword">FROM</span> segment_generator <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;short_code&#x27;</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><code>MULTIPLIER</code> 和 <code>INCREMENT</code>是两个大素数，<code>MOD</code> 为 <spanclass="math inline">2<sup>32</sup></span>。 当 <code>id</code> 位于<span class="math inline">[0,2<sup>32</sup>)</span>的范围时，线性混淆可以保证不出现重码。 这意味着短码的最大长度为</p><p><span class="math display">⌈32log<sub>62</sub>2⌉ = 6.</span></p><h2 id="方案-4分布式-id-base62-编码">方案 4：分布式 ID + Base62编码</h2><p>这一方案基于 Snowflake 分布式 ID 生成机制，再通过 Base62 编码将二进制ID 转换为短链码。 其优点是：</p><ol type="1"><li>全局唯一性：Snowflake 保证不同机器、不同时间生成的 ID 唯一。</li><li>去中心化：不依赖单点数据库即可生成 ID。</li><li>低可预测性：ID 随时间增长且包含机器信息，难以预测下一个 ID。</li></ol><p>缺点：</p><ol type="1"><li>短链长度较长：64 位 ID 转 Base62 最长可达 11位，在需要极短短链的场景可能略长。</li><li>ID 资源浪费：生成 ID 服务并发量过低时，可能出现资源浪费。</li></ol><p>Snowflake 算法默认生成 64 位 ID。 我们可以重新设计其 ID结构，降低长度。 假设我们的目标 Base 62 编码最大长度为 <spanclass="math inline"><em>x</em></span>，其对应的二进制位数最少为 <spanclass="math inline"><em>y</em></span>。 <spanclass="math inline"><em>y</em></span> 与 <spanclass="math inline"><em>x</em></span> 的关系由下式给出：</p><p><spanclass="math display"><em>y</em> = ⌊<em>x</em>log<sub>2</sub>62⌋.</span></p><table><thead><tr class="header"><th>Base 62 位数 <span class="math inline"><em>x</em></span></th><th>所需最少 Base 2 位数 <spanclass="math inline"><em>y</em></span></th></tr></thead><tbody><tr class="odd"><td>7</td><td>41</td></tr><tr class="even"><td>8</td><td>47</td></tr><tr class="odd"><td>9</td><td>53</td></tr><tr class="even"><td>10</td><td>59</td></tr><tr class="odd"><td>11</td><td>65</td></tr></tbody></table><p>为了得到更短的短链码，我们可以考虑缩减 Snowflake ID 的总位数：</p><ol type="1"><li>去除符号位。</li><li>将时间戳精度降低，从微秒级改为秒级。</li><li>减少机器数或序列号位数。</li></ol><p>不过，ID 位数缩减会直接降低每秒可生成的唯一 ID数量，因此我们必须在短链长度与高并发生成能力之间权衡。 如果对生成 ID的并发性能要求很高，那我们仍然应当使用 64 位的 ID，如果我们对短链的长度要求很高，则可以适当降低 ID 长度。</p><p>下面是一个较为均衡的 47 位 ID 设计，其对应的最大 Base 62 编码长度为 8位：</p><table><thead><tr class="header"><th>字段</th><th>位数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>时间戳（秒级）</td><td>30 bits</td><td>可用约 34 年</td></tr><tr class="even"><td>Worker ID</td><td>7 bits</td><td>128 台机器</td></tr><tr class="odd"><td>序列号</td><td>10 bits</td><td>每秒最多 1024 个</td></tr></tbody></table><p>但是，即便我们使用分布式 ID 生成机制，单机环境下多个线程并发生成 ID时仍可能出现竞态条件。 我的另一篇文章 <ahref="!--swig￼4--">并发雪花算法</a> 实现了基于 CAS 的 ID 生成算法。</p><h2 id="下一篇文章">下一篇文章</h2><p><a href="/shorto/resolve/">短链解析篇</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短链服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短链服务</title>
    <link href="/shorto/"/>
    <url>/shorto/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务">短链服务</h1><p>本系列文章主要探讨短链服务（Short URL Service）的工作原理和实现思路。<!-- ，并提供一个具体实现：[Shorto](https://github.com/FengNKT/shorto)。 -->共计包括以下几篇文章：</p><ol type="1"><li><a href="/shorto/generator/">短链生成篇</a></li><li><a href="/shorto/resolve/">短链解析篇</a></li><li><a href="/shorto/statistics/">数据统计篇</a>（撰写中）</li><li><a href="/shorto/backend/">后台管理篇</a>（撰写中）</li></ol><h2 id="基本原理">基本原理</h2><p>短链系统是一个常见的互联网基础服务，广泛用于二维码生成、短信链接、社交媒体跳转等场景。它的核心目标是： <strong>将冗长的原始 URL转换为简短的访问链接，并能快速地解析还原。</strong></p><p>我们首先来看一个短链的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs URL">https://example.com/2Yx4Gz<br></code></pre></td></tr></table></figure><p>其中，短链可以分为三个部分</p><ul><li>协议：使用 http 或 https；</li><li>域名：例子中的 <code>example.com</code> 部分。短链服务通常使用较短的域名，例如新浪提供的 t.cn，Bitly 提供的bit.ly；</li><li>短链码：例子中的 <code>2Yx4Gz</code> 部分。 短链码一般使用 Base62编码，即由数字、小写字母、大写字母组成。短链码越短越好，长度一般可以设计在 6-8 个字符。</li></ul><p>从功能上看，短链服务的核心逻辑其实非常简单： 服务维护一张“短链码 →原始链接”的映射表。当用户访问短链时，服务根据短链码查找对应的长链并返回一个重定向响应；如果映射不存在，则返回 404。</p><figure><img src="/shorto/flowchart.svg" alt="核心逻辑" /><figcaption aria-hidden="true">核心逻辑</figcaption></figure><p>虽然原理简单，但要让系统在真实业务环境中应对高并发访问、系统故障等问题，还需要一系列优化。</p><h2 id="服务特点分析">服务特点分析</h2><p>短链服务主要包括以下几个模块：</p><ol type="1"><li>核心服务模块，提供短链解析与生成的功能</li><li>数据统计模块</li><li>后台管理模块</li></ol><p>本项目的架构如下图所示：</p><figure><img src="/shorto/architechture.png" alt="短链服务架构图" /><figcaption aria-hidden="true">短链服务架构图</figcaption></figure><p>而三个模块的设计方式，取决于具体的业务场景。总体而言，我们需要关注以下几个方面：</p><ol type="1"><li><p><strong>性能</strong><br />不同的业务场景对解析和生成的性能要求有所不同。主要包括以下两种场景：</p><ol type="1"><li>解析高性能，生成低性能：例如秒杀页面短链、营销短信短链、线下实体二维码等。这类短链主要由后台批量生成，因此生成阶段可以接受一定延迟；而用户访问短链后的跳转速度必须足够快。</li><li>解析高性能，生成高性能： 例如社交媒体分享短链、实时动态二维码等。这类场景中短链生成由用户主动触发，对生成延迟更敏感，因此在解析与生成两个环节均需要高性能保证。这些短链的生成请求通常由用户主动发起，因而对延迟的忍受度较低。</li></ol></li><li><p><strong>映射关系</strong><br />长链与短链的映射方式通常包括两类：</p><ol type="1"><li>一一映射：同一长链始终生成同一个短链。</li><li>一对多映射：一条长链可以生成多条不同的短链。</li></ol><p>实际业务中第二种方式更为常见。</p></li><li><p><strong>短链长度</strong><br />短链应尽可能简洁，以便于展示或嵌入二维码。然而，过短的短链会显著提高冲突概率并增加生成算法的复杂度，影响性能。关于短链长度和生成算法性能之间的权衡，后文将进一步讨论。</p></li><li><p><strong>安全性</strong><br />短链的生成规则不应被轻易推测。</p></li></ol><h2 id="数据库设计">数据库设计</h2><table><thead><tr class="header"><th>表名</th><th>注释</th><th>用途</th></tr></thead><tbody><tr class="odd"><td><code>url_map</code></td><td>URL 映射表</td><td>记录<strong>短链-长链</strong>的映射关系</td></tr><tr class="even"><td><code>user</code></td><td>用户表</td><td>记录用户信息</td></tr><tr class="odd"><td><code>role</code></td><td>角色表</td><td>系统提供的角色，包括普通用户、VIP 用户、管理员等</td></tr><tr class="even"><td><code>user_role</code></td><td>用户-角色关联表</td><td>记录用户-角色的关联信息</td></tr><tr class="odd"><td><code>segement_generator</code></td><td>号段生成表</td><td>提供生成号段的能力，用于号段方案</td></tr></tbody></table><h2 id="下一篇文章">下一篇文章</h2><p><a href="/shorto/generator/">短链生成篇</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短链服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Solow 增长模型</title>
    <link href="/2023/02/11/solow-model/"/>
    <url>/2023/02/11/solow-model/</url>
    
    <content type="html"><![CDATA[<h2 id="一基本假设">一、基本假设</h2><h3 id="生产过程">1.生产过程</h3><p>我们首先假设，一个经济体在超长期中的生产过程，可以被分成无数个相继发生的短期生产过程。在经济体的每一期生产过程中，都有一定量的资本和劳动相结合，在一定的技术条件下，生产出一定量的产品。这些产品一部分用于这一期的消费，还有一部分用于投资，为下一期的生产做准备。</p><p>单个短期生产过程的图示为： <pre><code class=" mermaid">flowchart LRcapital(资本 K) &amp; labour(劳动 L) &amp; efficiency(劳动效率 E) --&gt; factors(生产要素) -- 生产过程 --&gt; product(产出 Y) --&gt; investment(投资 I) &amp; consumption(消费 C)</code></pre></p><p>首先考虑离散情形。 我们假设每一期生产过程所用时长均为 <spanclass="math inline"><em>h</em></span>。上述所有量首先可以被分为两类：</p><ul><li>存量：<spanclass="math inline"><em>K</em>, <em>L</em>, <em>E</em></span></li><li>流量：<spanclass="math inline"><em>Y</em>, <em>I</em>, <em>C</em></span></li></ul><p>我们认为这些量都是 <span class="math inline"><em>t</em></span>的函数，但是其含义却不尽相同：</p><ul><li>对于存量而言，它的含义是 <span class="math inline"><em>t</em></span>时刻该存量有多少；</li><li>对于流量而言，它的含义是 <spanclass="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内该流量有多少。</li></ul><p>下面考虑连续情形，即 <span class="math inline"><em>h</em> → 0</span>的情形。此时每个生产过程耗费的时间都是无穷小量，故其对应的产出、投资、消费也是无穷小量。为了让这些量仍然具有意义，我们必须修改它们的定义，即将流量修改为该变量在<span class="math inline"><em>t</em></span> 时刻的增长速率。</p><h3 id="生产函数">2.生产函数</h3><h4 id="总生产函数">2.1.总生产函数</h4><p>我们假设生产要素和产出之间存在函数关系，称作总生产函数 <spanclass="math inline"><em>F</em></span>。 具体来说，<spanclass="math inline"><em>F</em></span> 的定义是 <spanclass="math display">$$\begin{align*}    F:\mathbb{R}\times\mathbb{R}&amp;\to\mathbb{R}\\    (K,LE)&amp;\to Y.\end{align*}$$</span> 在离散情形下，<span class="math inline"><em>F</em></span> 将<span class="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了<span class="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内的产出； 在连续情形下，<spanclass="math inline"><em>F</em></span> 将 <spanclass="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了 <spanclass="math inline"><em>t</em></span> 时刻产出的增长速率。</p><p>为了方便研究，我们假设连续情形下 <spanclass="math inline"><em>F</em></span> 是可微的。</p><h4 id="规模报酬不变">2.2.规模报酬不变</h4><p>我们假设总生产函数具有规模报酬不变性质，即如果等比例地增加生产要素，产出也会按相同比例增加。在数学上，这意味着 <span class="math inline"><em>F</em></span>具有齐次性，即对任意的实数 <spanclass="math inline"><em>x</em>, <em>y</em>, <em>λ</em></span> 有 <spanclass="math inline"><em>F</em>(<em>λ</em><em>x</em>,<em>λ</em><em>y</em>) = <em>λ</em><em>F</em>(<em>x</em>,<em>y</em>)</span>。</p><h4 id="总资本边际产量">2.3.总资本边际产量</h4><p>在离散情形下，资本的边际产量 <span class="math inline">MPK</span>是生产要素组合的函数，含义是在该要素组合下，增加一单位资本带来的额外产出，即<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em>(<em>K</em>+1,<em>L</em><em>E</em>) − <em>F</em>(<em>K</em>,<em>L</em><em>E</em>).</span></p><p>很明显，在连续情形下，<span class="math inline">MPK</span> 的定义是<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em><sub>1</sub>(<em>K</em>,<em>L</em><em>E</em>).</span></p><h4 id="人均总生产函数">2.4.人均总生产函数</h4><p>在 Solow模型中，我们十分关注人均情形，但这里的人均情形是有效工人意义下的人均，例如人均资本被定义为总资本比有效工人，即人均资本<span class="math inline">$k:=\frac{K}{LE}$</span>。</p><p>由总生产函数的齐次性，不难得到 <span class="math display">$$y=\frac{Y}{LE}=\frac{1}{LE}F(K,LE)=F\left(\frac{K}{LE},1\right)=F(k,1).$$</span></p><p>但我们并不能就此断言 <span class="math inline"><em>k</em></span> 与<span class="math inline"><em>y</em></span> 之间存在函数关系。 因为<span class="math inline"><em>k</em></span>对应的可能生产要素组合构成了集合 <spanclass="math inline">{(<em>λ</em><em>k</em>,<em>λ</em>)|<em>λ</em> ∈ ℝ}</span>，即该集合中每一种生产要素组合对应的人均资本都是<span class="math inline"><em>k</em></span>。我们必须证明，对集合中的每一种生产要素组合，其对应的人均产量 <spanclass="math inline"><em>y</em></span> 都是相同的，这样 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间才存在函数关系。 否则，若一个<span class="math inline"><em>k</em></span> 对应了多个 <spanclass="math inline"><em>y</em></span>，则两者之间不存在函数关系。</p><p><em>证明：</em> 因为 <span class="math display">$$y=\frac{1}{\lambda}F(\lambda k,\lambda)=F(k,1),$$</span> 所以所有可能生产要素组合的 <spanclass="math inline"><em>y</em></span> 的值都等于 <spanclass="math inline"><em>F</em>(<em>k</em>,1)</span>，因而 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间存在函数关系。</p><p><em>证毕。</em></p><p>不妨将该函数记作 <spanclass="math inline"><em>f</em></span>，称作人均总生产函数，即 <spanclass="math display"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1).</span></p><h4 id="人均资本边际产量">2.5.人均资本边际产量</h4><p>与总生产函数类似，我们也可以为人均总生产函数定义资本边际产量。离散情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>(<em>k</em>+1) − <em>f</em>(<em>k</em>).</span></p><p>连续情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>′(<em>k</em>).</span></p><p>这里就产生了一个问题：人均情形的 <span class="math inline">MPK</span>和总的情形的 <span class="math inline">MPK</span> 的关系是什么。对于离散情形，两者并不存在确切的数量关系。 下面考虑连续情形：</p><blockquote><p>引理：若函数 <span class="math inline"><em>g</em></span> 是 <spanclass="math inline"><em>k</em></span> 阶齐次的，那么它的任一偏导数 <spanclass="math inline">∂<em>g</em>/∂<em>x</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>k</em> − 1</span> 阶齐次的。</p></blockquote><p>因为总生产函数 <span class="math inline"><em>F</em></span>是一阶齐次的（即齐次函数），所以 <spanclass="math inline"><em>F</em></span> 的偏导数 <spanclass="math inline"><em>F</em><sub>1</sub></span>是零阶齐次的，这意味着对任意的实数 <spanclass="math inline"><em>k</em>, <em>λ</em></span> 有 <spanclass="math display">MPK(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>k</em>,1) = <em>f</em>′(<em>k</em>) = MPK(<em>k</em>).</span>由此可以看出，人均资本 <span class="math inline"><em>k</em></span> 的<span class="math inline">MPK</span>，与其对应的各种总的生产要素组合<span class="math inline">(<em>λ</em><em>k</em>,<em>λ</em>)</span> 的<span class="math inline">MPK</span> 是相同的。</p><h3 id="符号表">3.符号表</h3><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">符号</th><th style="text-align: center;">定义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">社会总资本</td><td style="text-align: center;"><spanclass="math inline"><em>K</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均资本</td><td style="text-align: center;"><spanclass="math inline"><em>k</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{K}{LE}$</span></td></tr><tr class="odd"><td style="text-align: center;">社会总劳动</td><td style="text-align: center;"><spanclass="math inline"><em>L</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">社会总产出</td><td style="text-align: center;"><spanclass="math inline"><em>Y</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均产出</td><td style="text-align: center;"><spanclass="math inline"><em>y</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{Y}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总投资</td><td style="text-align: center;"><spanclass="math inline"><em>I</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均投资</td><td style="text-align: center;"><spanclass="math inline"><em>i</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{I}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总消费</td><td style="text-align: center;"><spanclass="math inline"><em>C</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均消费</td><td style="text-align: center;"><spanclass="math inline"><em>c</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{C}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率</td><td style="text-align: center;"><spanclass="math inline"><em>E</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>F</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>f</em></span></td><td style="text-align: center;"><spanclass="math inline"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1)</span></td></tr><tr class="odd"><td style="text-align: center;">储蓄率</td><td style="text-align: center;"><spanclass="math inline"><em>s</em></span></td><td style="text-align: center;">产出中未消费的比例</td></tr><tr class="even"><td style="text-align: center;">折旧率</td><td style="text-align: center;"><spanclass="math inline"><em>δ</em></span></td><td style="text-align: center;">资本损耗的比例</td></tr><tr class="odd"><td style="text-align: center;">劳动力增长率</td><td style="text-align: center;"><spanclass="math inline"><em>n</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaL}{L}$</span> 或 <span class="math inline">$\frac{L'}{L}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率增长率</td><td style="text-align: center;"><spanclass="math inline"><em>g</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaE}{E}$</span> 或 <span class="math inline">$\frac{E'}{E}$</span></td></tr><tr class="odd"><td style="text-align: center;">资本边际产量</td><td style="text-align: center;"><spanclass="math inline">MPK</span></td><td style="text-align: center;"></td></tr></tbody></table><h2 id="二资本增长方程">二、资本增长方程</h2><p>Solow 模型描述了资本的增长规律，本节探讨的资本增长方程是 Solow模型最核心的部分。</p><h3 id="资本的增长过程">1.资本的增长过程</h3><p>如果我们把资本看作单个生产过程的起点，那么整个过程就变为资本的增长过程：<pre><code class=" mermaid">flowchart TB    capital(资本) -- 投入生产 --&gt; factors(生产要素) -- 生产 --&gt; product(产品) --&gt; investment(投资) -- 资本更新 --&gt; capital(资本)</code></pre></p><p>如果我们进一步将资本以外的环节全部抽象成生产过程，资本的增长过程就变为：<pre><code class=" mermaid">flowchart TB    capital(资本) --投入生产--&gt; produce(生产)    produce(生产) --资本更新--&gt; capital(资本)</code></pre></p><p>资本首先作为生产要素进入生产过程。资本在生产过程中资本会有一定的损耗，称作<strong>资本折旧</strong>，这是资本在增长过程中减少的部分。生产出的产品一部分用于消费，另一部分用于<strong>投资</strong>，这是资本在增长过程中增加的部分。Solow模型最核心的思想是，资本净增长等于投资（增加的部分）减去资本折旧（减少的部分），即：<span class="math display">资本增量 = 投资 − 资本折旧.</span></p><p>产出中未消费的比例称作<strong>储蓄率</strong> <spanclass="math inline"><em>s</em></span>，所以每次生产完成后未消费的产出的量是<span class="math inline"><em>s</em><em>Y</em></span>。 根据<ahref="https://en.wikipedia.org/wiki/Saving_identity">储蓄-投资恒等式</a>，未消费的部分即投资，所以投资的量也是<span class="math inline"><em>s</em><em>Y</em></span>。</p><p>资本折旧占资本的比例称作<strong>折旧率</strong> <spanclass="math inline"><em>δ</em></span>，所以每次生产损耗的资本是 <spanclass="math inline"><em>δ</em><em>K</em></span>。</p><h3 id="总资本增长方程">2.总资本增长方程</h3><p>首先考虑离散情形。 用符号代替上面的资本增长方程，就得到： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>Y</em><sub><em>t</em></sub> − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub></span>再用 <spanclass="math inline"><em>Y</em><sub><em>t</em></sub> = <em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>)</span>代入上式，就得到离散情形下的总资本增长方程： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>) − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub>.</span></p><p>连续情形的总资本增长方程同理可得： <span class="math display">$$\frac{dK_t}{dt}=s_tF(K_t,L_tE_t)-\delta_tK_t.$$</span></p><h3 id="人均资本增长方程">3.人均资本增长方程</h3><p>从总资本增长方程出发，我们不难得到人均资本增长方程。</p><p>离散情形的人均资本增长方程： <span class="math display">$$\Delta k_t=\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \Delta k_t    =&amp;\Delta\left(\frac{K_t}{L_tE_t}\right)    =\frac{(\Delta K_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\DeltaE_t]}{(L_{t+1}E_{t+1})(L_tE_t)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\frac{(\DeltaK_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\Delta E_t]}{(L_tE_t)^2}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(代入总资本增长方程)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(由生产函数的齐次性)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t]\\    =&amp;\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程： <span class="math display">$$\frac{dk_t}{dt}=s_tf(k_t)-(\delta_t+n_t+g_t)k_t.$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \frac{dk_t}{dt}    =&amp;\left(\frac{K_t}{L_tE_t}\right)'    =\frac{K'_tL_tE_t-K_t(L'_tE_t+L_tE'_t)}{(L_tE_t)^2}\\    =&amp;\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(代入总资本增长方程)}\\    =&amp;s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(由生产函数的齐次性)}\\    =&amp;s_tf(k_t)-(\delta_t+n_t+g_t)k_t.\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程是 Solow 模型最常见的表述。</p>]]></content>
    
    
    <categories>
      
      <category>经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西方经济学</tag>
      
      <tag>宏观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ机器人搭建教程</title>
    <link href="/2023/02/06/qq-bot-tutorial/"/>
    <url>/2023/02/06/qq-bot-tutorial/</url>
    
    <content type="html"><![CDATA[<p>本文先简要阐述现在流行的QQ机器人的工作原理，再介绍一个机器人搭建案例。</p><p>要编写一个QQ机器人，至少需要实现两种功能：</p><ol type="1"><li>机器人和QQ服务器之间的通信。</li><li>机器人对QQ消息的处理。</li></ol><h2id="一机器人和qq服务器之间的通信">一、机器人和QQ服务器之间的通信</h2><p>机器人和QQ服务器之间有以下几种通信方式。</p><h3 id="通信方式1直接通信">1.通信方式1：直接通信</h3><!-- > 通信方式1：【QQ服务器】---QQ协议---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(机器人)</code></pre><p>QQ客户端与服务端之间依赖于一套特定协议来通信，暂且称作<strong>QQ协议</strong>。如果我们知道了协议的具体内容，就可以伪装成QQ客户端，按这套协议直接向服务端发送信息，并且按这套协议解析服务端发来的信息。</p><p>但该做法存在以下几个问题：</p><ul><li>逆向工程。QQ的协议由腾讯公司私有，我们并不知道其具体内容。所以我们需要对QQ客户端进行逆向工程，但这个工作相当复杂。</li><li>网络编程。为了发送QQ消息，我们需要编写相应代码来封装、发送QQ消息；为了接收QQ消息，我们也需要编写相应代码来接收、解析QQ消息。</li></ul><p>但是在编写机器人时，我们最应该关心的是机器人处理QQ消息的逻辑，而不是这些底层且复杂的工作。</p><h3id="通信方式2通过中间层进行通信">2.通信方式2：通过中间层进行通信</h3><!-- > 通信方式2：【QQ服务器】---QQ协议---【中间层】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中间层)-- 库调用 ---id3(机器人)</code></pre><p>为了解决上述两个问题，我们可以编写一个<strong>中间层</strong>。一方面，中间层与QQ服务器进行具体的通信；另一方面，中间层为我们提供简单易用的<strong>库接口</strong>。在编写机器人时，我们只需要直接调用这些库接口，让中间层去进行具体的通信工作。这样，逆向工程和网络编程就由编写中间层的程序员完成；而编写机器人的程序员不再需要操心这些底层问题，只需了解库接口如何调用。</p><p>这种通信方式依然存在一个问题：通常来说，编写机器人和编写中间层的语言应该是相同的。例如，我们使用的是实现为Java库的中间层，那么我们只能使用Java语言来调用中间层的接口。于是，编写机器人的语言种类受到了限制。</p><h3id="通信方式3通过中间层和适配器进行通信">3.通信方式3：通过中间层和适配器进行通信</h3><!-- > 通信方式3：【QQ服务器】---QQ协议---【中间层】---中间层协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中间层)-- 中间层协议 ---id3(适配器)-- 库调用 ---id4(机器人)</code></pre><p>为了让各种语言都可以使用同一个中间层，我们可以将中间层实现为独立运行的软件，提供<strong>通用的本地网络接口</strong>（例如：HTTP，Websocket，ReverseWebsocket），制订一套简单的中间层接口协议。这样，不管我们使用什么编程语言，只要按协议调用这些接口，就可以使用中间层的功能。</p><p>但提升中间层通用性带来的代价是，我们又要面对网络编程这个麻烦事（机器人和中间层之间通过本地网络通信）。为了回避网络编程，我们可以为每种编程语言开发相应的<strong>适配器</strong>（实现为库），只需调用适配器提供的库接口，让适配器与中间层进行沟通。</p><blockquote><p>这种通信方式的确比前一种更加迂回。如果我们为每一种编程语言开发相应的中间层库而非适配器，就可以避免迂回。之所以不这么做，是因为开发中间层的工作量要大于开发适配器，提高中间层的通用性更加划算。</p></blockquote><h3 id="推荐的中间层mirai">4.推荐的中间层：Mirai</h3><p>常见的中间层有 Mirai，酷Q，oicq 等等。 本文推荐 <ahref="https://github.com/mamoe/mirai">Mirai</a> 的理由有：</p><ol type="1"><li>全平台通用。Mirai 由 Kotlin 语言编写，可以运行在Windows，Linux，MacOS 等操作系统上。</li><li>小巧。我电脑上的 mirai-console 只有 60 多 M。</li><li>开源。</li></ol><p>Mirai 本身是一个库，也就是说我们需要使用 Kotlin编写机器人，按照上述的<em>通信方式2</em>与QQ服务器进行通信。</p><p>但 Mirai 官方也将 Mirai 实现为了一个独立运行的程序，名为 <ahref="https://github.com/mamoe/mirai/tree/dev/mirai-console">mirai-console</a>。mirai-console 中安装了 mirai-api-http 插件后，就可以提供本地网络接口。于是我们可以使用任何编程语言，按照上述的<em>通信方式3</em>与QQ服务器进行通信。</p><h3 id="其他聊天软件">5.其他聊天软件</h3><p>上述通信方式并不局限于和QQ服务器的通信。如果我们要编写其他聊天软件的机器人，通信方式也是类似的。有些聊天软件还提供公开的接口，例如钉钉、Discord。为这些软件编写机器人时，我们就不需要中间层的帮助了。例如钉钉机器人的通信方式是：<!-- > 通信方式（钉钉）：【钉钉服务器】---DingTalk协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(钉钉服务器)-- DingTalk协议 ---id2(适配器)-- 库调用 ---id3(机器人)</code></pre></p><h2 id="二机器人框架">二、机器人框架</h2><p>机器人不管为何种聊天软件编写，都具有一些类似的特点：</p><ul><li>消息驱动。通常来说，机器人是被动地处理消息，接收到特定命令时完成特定功能。</li><li>插件系统。通常机器人提供的功能不止一种。为了方便编程，我们可以将各种功能抽象为插件，实现一个插件管理系统，根据接收到的命令运行特定插件。</li><li>异步编程。要让机器人可以同时处理多个命令，需要用到异步编程。</li><li>……</li></ul><p>于是，我们可以进一步抽象出一个具有上述功能的机器人框架。它不但可以帮助我们更简单地编写一个机器人，还可以让我们的机器人具有跨聊天平台的特性。</p><p>机器人框架的种类十分丰富。选取哪一个机器人框架，取决于我们选用的语言、中间层。</p><h2 id="三机器人搭建方案">三、机器人搭建方案</h2><p>要搭建一个机器人，我们需要决定三件事：</p><ol type="1"><li>选取什么中间层。</li><li>选取什么编程语言。</li><li>选取什么机器人框架。</li></ol><blockquote><p>适配器通常包含于机器人框架内，不需要选取。</p></blockquote><p>下面提供了几种选取方案：</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: center;">中间层</th><th style="text-align: center;">编程语言</th><th style="text-align: center;">通信方式</th><th style="text-align: center;">机器人框架</th><th style="text-align: center;">mirai-console</th><th style="text-align: center;">mirai-api-http</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">✅</td><td style="text-align: center;">❌</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/iTXTech/mirai-kts">Mirai Kts</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">C++</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/cyanray/mirai-cpp">mirai-cpp</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://v2.nonebot.dev/">NoneBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://docs.alicebot.dev/">AliceBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr></tbody></table><p>更多机器人框架可以参见 <ahref="https://docs.mirai.mamoe.net/#http-%E6%8E%A5%E5%8F%A3">mirai开发文档（HTTP 接口）</a>。 方案1是将 Mirai 作为库来调用，所以不需要mirai-console 和 mirai-api-http ； 方案2是将机器人写成 mirai-console的插件，被它调用，所以需要 mirai-console。</p><p>有关 Mirai 生态的更多内容，参见 <ahref="https://docs.mirai.mamoe.net/mirai-ecology.html">mirai开发文档（生态简介）</a>。</p><h2 id="四案例miraialicebot-环境搭建">四、案例：Mirai+AliceBot环境搭建</h2><p>下面详细介绍方案6的环境搭建。<!-- > 通信方式：【QQ服务器】---QQ协议---【Mirai】---Mirai API---【AliceBot适配器】---库调用---【AliceBot】 --></p><p>方案6的通信方式： <pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(Mirai)-- Mirai API ---id3(AliceBot适配器)-- 库调用 ---id4(AliceBot)</code></pre></p><p>安装清单：</p><ol type="1"><li>JRE：Java 运行时。Mirai 基于 Kotlin 开发，需要 JRE 环境。</li><li>mirai-console：独立运行的中间层。</li><li>mirai-api-http：提供本地网络接口的中间层插件。</li><li>alicebot：机器人框架。</li><li>alicebot-adapter-mirai：与 alicebot 配套的 mirai 适配器。</li></ol><h3 id="安装-mirai">1.安装 Mirai</h3><p>我们可以使用 Mirai 官方提供的<ahref="https://github.com/iTXTech/mcl-installer/releases">自动安装器</a>来安装mirai-console。 如果计算机上没有 JRE，自动安装器也可以帮助安装。 &gt;mirai-console 有两个版本，一个有 GUI 界面，一个没有，详情参见 <ahref="https://github.com/mamoe/mirai/blob/dev/docs/UserManual.md">Mirai用户手册</a>。自动安装器安装的是无 GUI 界面版本。</p><p>mirai-console 安装完成后，安装目录中会出现名为 mcl(Mirai ConsoleLoader) 的脚本。 运行此脚本即可启动 mirai-console。</p><p>安装 mirai-api-http 插件可以利用 mirai-console 命令：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl --update-package net.mamoe:mirai-api-http --channel stable --<span class="hljs-built_in">type</span> plugin<br></code></pre></td></tr></table></figure></p><h3 id="初步配置-mirai">2.初步配置 Mirai</h3><p>运行 mcl 脚本来启动 mirai-console： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl<br></code></pre></td></tr></table></figure></p><p>mirai-console 成功启动后，可以输入 <code>/help</code>查看帮助文档。</p><p>登录 QQ 账号的命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/login &lt;qq&gt; [password] [protocol]<br></code></pre></td></tr></table></figure></p><p>设置自动登录： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autoLogin add &lt;account&gt; &lt;password&gt;<br></code></pre></td></tr></table></figure></p><p>退出 mirai-console： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/stop<br></code></pre></td></tr></table></figure></p><p>mirai-console 支持的登录协议有<code>ANDROID_PHONE</code>、<code>ANDROID_PAD</code>、<code>ANDROID_WATCH</code>、<code>MACOS</code>、<code>IPAD</code>五种。 QQ服务器通过登录协议来识别登录设备的种类。 mirai-console 默认使用<code>ANDROID_PHONE</code> 协议登录，因此 mirai 会将自身伪装成安卓手机。如果想要让手机和 mirai-console同时登录一个账号，我们可以将登录协议切换为<code>ANDROID_PAD</code>，因为QQ允许安卓手机和平板同时登陆。切换自动登录使用的协议： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autologin setConfig &lt;account&gt; protocol &lt;protocol&gt;<br></code></pre></td></tr></table></figure></p><h3 id="mirai-console-目录结构">3.mirai-console 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Directory">.<br>├── config<br>│   ├── Console<br>│   │   ├── AutoLogin.yml<br>│   │   └── ...<br>│   └── net.mamoe.mirai-api-http<br>│       └── setting.yml<br>├── plugins<br>└── ...<br></code></pre></td></tr></table></figure><ul><li><code>./config/Console/AutoLogin.yml</code>文件包含自动登录的相关配置。</li><li><code>./config/net.mamoe.mirai-api-http/setting.yml</code> 文件包含mirai-api-http 插件的相关配置。安装该插件并运行 mirai-console之后才会生成此文件。</li><li><code>./plugins</code> 文件夹用于存放 mirai-console插件。mirai-console 启动后会自动加载该文件夹中的插件。</li></ul><blockquote><p>mirai-console 的插件可以在 <ahref="https://mirai.mamoe.net/category/11/%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83">Mirai论坛</a> 下载。</p></blockquote><h3 id="安装-alicebot">4.安装 AliceBot</h3><p>使用 pip 安装即可。 安装 alicebot： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot<br></code></pre></td></tr></table></figure> 安装alicebot-adapter-mirai： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot-adapter-mirai<br></code></pre></td></tr></table></figure> ### 5.配置 AliceBot 在配置AliceBot 之前建议先了解其<ahref="https://docs.alicebot.dev/guide/index.html">工作原理</a>。AliceBot 是 Python 库，并非独立运行的软件，我们需要编写 Python脚本并调用 AliceBot 库来实现一个机器人。 可以参照其<ahref="https://docs.alicebot.dev/guide/getting-started.html">开发文档（快速上手）</a>编写一个简单的AliceBot 项目。</p><p>要让 AliceBot 正常工作，必须先对 AliceBot 和 Mirai进行配置，让它们能够正确地通信，详细配置方式参照其<ahref="https://docs.alicebot.dev/guide/basic-config.html">开发文档（基本配置）</a>和<ahref="https://docs.alicebot.dev/guide/mirai-adapter.html">开发文档（Mirai协议适配器）</a>。 配置的关键之处在于让 AliceBot 和 Mirai选择同一套网络协议，并且使用相同的 <code>verify_key</code>。</p><h3 id="运行">6.运行</h3><p>mirai-console 和 AliceBot机器人脚本是两个独立的程序，它们之间通过本地网络接口通信。因此，在运行机器人时，我们必须同时运行两个程序。至于两个程序的存放路径则是无关紧要的，我们可以把它们放在同一目录下，也可以不这么做。我们可以将自己或他人编写的 AliceBot插件放在指定的插件目录下，它就会自动运行该插件。 AliceBot插件的编写方式参考<ahref="https://docs.alicebot.dev/guide/plugin-basics.html">开发文档(插件基础)</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
