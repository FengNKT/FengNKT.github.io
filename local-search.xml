<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>短链服务</title>
    <link href="/2025/11/01/short-url/"/>
    <url>/2025/11/01/short-url/</url>
    
    <content type="html"><![CDATA[<h1 id="短链服务">短链服务</h1><p>本文简要探讨短链服务（Short URLService）的工作原理和实现思路，并提供一个具体实现：<ahref="https://github.com/FengNKT/short-url-service">项目地址</a>。</p><p>短链系统是一个常见的互联网基础服务，广泛用于二维码生成、短信链接、社交媒体跳转等场景。它的核心目标是： <strong>将冗长的原始 URL转换为简短的访问链接，并能快速地解析还原。</strong></p><h2 id="短链服务的基本原理">短链服务的基本原理</h2><p>我们首先来看一个短链的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs URL">https://example.com/2Yx4Gz<br></code></pre></td></tr></table></figure><p>其中，短链可以分为三个部分</p><ul><li>协议：使用 http 或 https；</li><li>域名：例子中的 <code>example.com</code> 部分。短链服务通常使用较短的域名，例如新浪提供的 t.cn，Bitly 提供的bit.ly；</li><li>短链码：例子中的 <code>2Yx4Gz</code> 部分。 短链码一般使用 Base62编码，即由数字、小写字母、大写字母组成。短链码越短越好，长度一般可以设计在 6-8 个字符。</li></ul><p>从功能上看，短链服务的核心逻辑其实非常简单： 服务维护一张“短链码 →原始链接”的映射表。当用户访问短链时，服务根据短链码查找对应的长链并返回一个重定向响应；如果映射不存在，则返回 404。</p><pre><code class=" mermaid">flowchart TD    A[用户请求] --&gt; B&#123;短链是否存在?&#125;    B --&gt;|是| C[返回302, 重定向至对应长链]    B --&gt;|否| D[返回404]</code></pre><p>虽然原理简单，但要让系统在真实业务环境中应对高并发访问、系统故障等问题，还需要一系列工程层面的优化。</p><p>本项目最终的架构如下图所示：</p><figure><img src="/img/architechture.png" alt="短链服务架构图" /><figcaption aria-hidden="true">短链服务架构图</figcaption></figure><h2 id="数据库设计">数据库设计</h2><p>本项目一共使用三张表。 最基本的 URL 映射表的 DDL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `url_map` (<br>    `id` <span class="hljs-type">bigint</span> unsigned <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>    `short_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;短链码&#x27;</span>,<br>    `long_url` <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;长链URL&#x27;</span>,<br>    `description` <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    `url_status` tinyint <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span> COMMENT <span class="hljs-string">&#x27;URL状态,1:正常,2:已失效&#x27;</span>,<br>    `create_time` datetime <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    `creator` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;创建者&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>    <span class="hljs-keyword">UNIQUE</span> KEY `url_map_unique` (`short_code`),<br>    KEY `url_map_short_code_IDX` (`short_code`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">14</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;URL映射表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>解析记录表的 DDL 如下： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `resolve_record` (<br>    `id` <span class="hljs-type">bigint</span> unsigned <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>    `short_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;短链码&#x27;</span>,<br>    `client_ip` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;客户端IP&#x27;</span>,<br>    `record_time` datetime <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;记录时间戳&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">12</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;解析记录表&#x27;</span>;<br></code></pre></td></tr></table></figure></p><p><code>segment_generator</code> 表用于号段分配： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE TABLE</span> `segment_generator` (<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT NULL</span>,<br>  `max_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`name`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure></p><h2 id="短链解析服务">短链解析服务</h2><p>短链解析模块承担核心任务：根据短链码查找原始 URL。在最初级的实现中，我们可以直接通过一条数据库查询实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLongUrl</span><span class="hljs-params">(String shortCode)</span> &#123;<br>    <span class="hljs-comment">// 查询数据库</span><br>    <span class="hljs-type">UrlMap</span> <span class="hljs-variable">urlMap</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;short_code&quot;</span>, shortCode).one();<br>    <span class="hljs-keyword">if</span> (urlMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果不存在，返回 null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    longUrl = urlMap.getLongUrl();<br>    <br>    <span class="hljs-keyword">return</span> longUrl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这虽然功能完备，但当请求量上升时，数据库很快会成为性能瓶颈。因此，我们需要引入缓存层（Redis）来加速查询。通常短链服务的读写比例极不平衡，读操作远多于写操作。使用缓存后，我们可以将热点短链的映射直接存放在 Redis中，大幅提升性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLongUrl</span><span class="hljs-params">(String shortCode)</span> &#123;<br>    <span class="hljs-comment">// 1.查询缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> URL_MAP_KEY_PREFIX + shortCode;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">longUrl</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(longUrl)) &#123;<br>        <span class="hljs-keyword">return</span> longUrl;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.查询数据库</span><br>    <span class="hljs-type">UrlMap</span> <span class="hljs-variable">urlMap</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;short_code&quot;</span>, shortCode).one();<br>    <span class="hljs-keyword">if</span> (urlMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    longUrl = urlMap.getLongUrl();<br><br>    <span class="hljs-comment">// 3.更新缓存</span><br>    stringRedisTemplate.opsForValue().set(key, longUrl, URL_MAP_CACHE_DURATION);<br><br>    <span class="hljs-keyword">return</span> longUrl;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是缓存可能出现以下几个问题：</p><h3 id="问题-1缓存穿透">问题 1：缓存穿透</h3><p>缓存穿透是指用户请求的数据在缓存和数据库中都不存在，每次请求都会打到数据库上，造成压力。我们可以考虑如下几个方案：</p><ol type="1"><li>对短链码合法性进行初步校验。</li><li>使用布隆过滤器（Bloom Filter）在缓存层前进行预过滤。</li><li>对于查询不到的短链，在 Redis中缓存一个“空值”一段时间，避免反复访问数据库。</li></ol><p>修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ShortCodeBloom shortCodeBloom;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLongUrl</span><span class="hljs-params">(String shortCode)</span> &#123;<br>    <span class="hljs-comment">// 1.检验短链码合法性</span><br>    <span class="hljs-keyword">if</span> (!ShortCodeValidator.isValidShortCode(shortCode)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.查询布隆过滤器</span><br>    <span class="hljs-keyword">if</span> (!shortCodeBloom.contains(shortCode)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.查询缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> URL_MAP_KEY_PREFIX + shortCode;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">longUrl</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(longUrl)) &#123;<br>        <span class="hljs-keyword">return</span> longUrl;<br>    &#125;<br><br>    <span class="hljs-comment">// 4.查询数据库</span><br>    <span class="hljs-type">UrlMap</span> <span class="hljs-variable">urlMap</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;short_code&quot;</span>, shortCode).one();<br>    <span class="hljs-keyword">if</span> (urlMap == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 缓存空值</span><br>        stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, URL_MAP_EMPTY_CACHE_DURATION);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    longUrl = urlMap.getLongUrl();<br><br>    <span class="hljs-comment">// 5.更新缓存</span><br>    stringRedisTemplate.opsForValue().set(key, longUrl, URL_MAP_CACHE_DURATION);<br><br>    <span class="hljs-keyword">return</span> longUrl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>ShortCodeBloom</code> 的实现使用了 Redisson 提供的<code>RBloomFilter</code>。</p><h3 id="问题-2缓存击穿">问题 2：缓存击穿</h3><p>缓存击穿是指<strong>高并发访问</strong>且<strong>缓存重建业务较复杂</strong>的热点key 失效，无数的请求瞬间给数据库带来巨大的冲击。对于我们的服务而言，重建 key 只涉及一次数据库查询和一次 Redis写请求，比较简单，所以缓存击穿的风险不高。</p><h3 id="问题-3缓存雪崩">问题 3：缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis服务宕机，导致大量请求到达数据库，带来巨大压力。对于我们的短链解析服务而言，缓存 key的过期时间更可能是随机的，因此主要需要关注 Redis 服务宕机的问题。可以考虑如下几个方案：</p><ol type="1"><li>使用 Redis 集群提高可用性。</li><li>添加限流策略。</li><li>使用多级缓存。</li></ol><p>我们在这里使用 Caffeine 提供的本地缓存。使用方法也十分简便，只需要给函数体添加 <code>@Cacheable</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;urlMapCache&quot;, key = &quot;#shortCode&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getLongUrl</span><span class="hljs-params">(String shortCode)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="短链生成服务">短链生成服务</h2><p>短链生成服务的核心在于短链生成算法的设计。为了构建一个合理、高效的短链生成算法，我们需要先分析短链服务所具备的主要特征：</p><ol type="1"><li>并发特性：短链解析请求的并发量通常很高，而短链生成的并发量相对较低。</li><li>性能需求：用户对短链解析的速度要求极高，但对短链生成的延迟容忍度较高，通常可接受数秒的等待时间。</li><li>映射关系：每个短链应当唯一对应一个长链，而同一个长链则可以对应多个不同的短链。</li><li>长度要求：短链应尽可能简短，一般长度控制在 6～8 个字符之间。</li><li>安全性：短链的生成规则不应被轻易推测，以防止被恶意猜测或批量生成。</li></ol><h3 id="方案-1数据库自增-id-base62-编码">方案 1：数据库自增 ID + Base62编码</h3><p>这是最容易想到的一种算法，也是本项目所使用的方案。 思路大致如下：</p><ol type="1"><li>数据库维护一个自增 ID。</li><li>每生成一个短链，就从数据库拿到一个新的 ID。</li><li>将 ID 编码为 62 进制（数字 + 大写字母 + 小写字母）得到短链。</li></ol><p>这个方案的优点是：</p><ol type="1"><li>数据库实现容易。</li><li>天然保证唯一性。</li></ol><p>可是这个方案的缺点也很明显：</p><ol type="1"><li>短链可被预测。</li><li>单点数据库生成 ID 可能成为瓶颈。</li></ol><p>为了解决这两个问题，我们可以用号段方案降低单点压力，并且使用轻量级的线性混淆。</p><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;autoIncrementShortCodeGenerator&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoIncrementShortCodeGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShortCodeGenerator</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ISegmentGenerator segmentGenerator;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SEGMENT_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MULTIPLIER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1580030173L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">59260789L</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">generate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1.获取新 id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> current.getAndIncrement();<br><br>        <span class="hljs-comment">// 2.如果 id 达到最大值，申请新号段</span><br>        <span class="hljs-keyword">if</span> (id &gt;= maxId) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">if</span> (current.get() &gt;= maxId) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">newMax</span> <span class="hljs-operator">=</span> segmentGenerator.nextSegment(SEGMENT_SIZE);<br>                    current.set(newMax - SEGMENT_SIZE);<br>                    maxId = newMax;<br>                &#125;<br>                id = current.getAndIncrement();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3.线性混淆</span><br>        id = (id * MULTIPLIER + INCREMENT) % MOD;<br><br>        <span class="hljs-comment">// 4.Base62 编码</span><br>        <span class="hljs-keyword">return</span> Base62Encoder.encode(id);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>SegmentGenerator</code> 的 <code>nextSegment</code>方法基于事务实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> segment_generator <span class="hljs-keyword">SET</span> max_id <span class="hljs-operator">=</span> max_id <span class="hljs-operator">+</span> #&#123;segmentSize&#125; <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;short_code&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> max_id <span class="hljs-keyword">FROM</span> segment_generator <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;short_code&#x27;</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p><code>MULTIPLIER</code> 和 <code>INCREMENT</code>是两个大素数，<code>MOD</code> 为 <spanclass="math inline">2<sup>32</sup></span>。 当 <code>id</code> 位于<span class="math inline">[0,2<sup>32</sup>)</span>的范围时，线性混淆可以保证不出现重码。 这意味着短码的最大长度为</p><p><span class="math display">⌈32log<sub>62</sub>2⌉ = 6.</span></p><h3 id="方案-2长链哈希-截断-冲突处理">方案 2：长链哈希 + 截断 +冲突处理</h3><p>对长链做哈希（MD5、SHA256），取前 N 位作为短链。</p><ul><li>优点：无需自增 ID，可批量离线生成，输入相同 URL可得到相同短链。</li><li>缺点：哈希冲突不可避免，需查询数据库或缓存判断短链是否存在，安全性较低。</li></ul><h3 id="方案-3分布式-id-base62-编码">方案 3：分布式 ID + Base62编码</h3><p>类似 Snowflake 算法生成分布式 ID，再 Base62 编码。</p><ul><li>优点：保证唯一性，不依赖单点数据库，低可预测性。</li><li>缺点：生成 ID后短链长度可能较长，且短链生成服务并发量较低，可能资源浪费。</li></ul><h2 id="统计模块">统计模块</h2><p>短链服务除了生成和解析功能外，还应提供统计分析能力，例如：</p><ol type="1"><li>访问次数、来源统计；</li><li>地理位置与设备分布；</li><li>日志采集与异常监控。</li></ol><h3 id="记录解析日志">记录解析日志</h3><p>由于短链解析请求频繁，若在主线程中直接记录解析日志或统计数据，会严重影响响应延迟。因此，我们采用<strong>主线程快速响应 +异步后台持久化</strong>的方式来记录解析日志。</p><p>实现核心思路： 1. 每次解析成功或失败后，生成一条<code>ResolveRecord</code>； 2. 主线程将记录放入内存队列<code>ResolveRecordQueue</code> 中； 3.后台由一组消费者线程从队列取出记录，异步批量持久化； 4.应用关闭时，主动清空队列，防止数据丢失。</p><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>ResolveRecordQueue resolveRecordQueue;<br><span class="hljs-meta">@Resource</span><br>ThreadPoolTaskExecutor recordExecutor;<br><span class="hljs-meta">@Resource</span><br>IResolveRecordService resolveRecordService;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONSUMERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startConsumers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CONSUMERS; i++) &#123;<br>        recordExecutor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                List&lt;ResolveRecord&gt; batch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>                <span class="hljs-type">ResolveRecord</span> <span class="hljs-variable">firstResolve</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    firstResolve = resolveRecordQueue.poll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.error(<span class="hljs-string">&quot;从队列获取记录失败&quot;</span>, e);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (firstResolve != <span class="hljs-literal">null</span>) &#123;<br>                    batch.add(firstResolve);<br>                    resolveRecordQueue.drainTo(batch, <span class="hljs-number">99</span>); <span class="hljs-comment">// 一次性取出剩余的</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (!batch.isEmpty()) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> resolveRecordService.saveBatch(batch);<br>                    <span class="hljs-keyword">if</span> (!success) &#123;<br>                        log.error(<span class="hljs-string">&quot;保存解析记录失败，共 &#123;&#125; 条&quot;</span>, batch.size());<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopConsumer</span><span class="hljs-params">()</span> &#123;<br>    log.info(<span class="hljs-string">&quot;应用即将关闭，正在保存剩余解析记录...&quot;</span>);<br>    running = <span class="hljs-literal">false</span>;<br>    List&lt;ResolveRecord&gt; remaining = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    resolveRecordQueue.drainTo(remaining);<br>    <span class="hljs-keyword">if</span> (!remaining.isEmpty()) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> resolveRecordService.saveBatch(remaining);<br>        <span class="hljs-keyword">if</span> (success) &#123;<br>            log.info(<span class="hljs-string">&quot;剩余 &#123;&#125; 条解析记录已保存&quot;</span>, remaining.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.error(<span class="hljs-string">&quot;保存剩余解析记录失败，共 &#123;&#125; 条&quot;</span>, remaining.size());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>组件</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>ResolveRecordQueue</code></td><td>内存中的阻塞队列，临时存放访问记录，底层使用<code>BlockingQueue</code> 实现。</td></tr><tr class="even"><td><strong><code>ThreadPoolTaskExecutor</code></strong></td><td>Spring提供的线程池执行器，用于运行消费者任务，可灵活控制线程数量。</td></tr><tr class="odd"><td><strong><code>IResolveRecordService</code></strong></td><td>负责将记录批量写入数据库的服务层接口。</td></tr></tbody></table><p>可进一步扩展至 Kafka 或 RocketMQ，将日志流式写入分析系统（如ClickHouse），实现更强的实时分析能力。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Solow 增长模型</title>
    <link href="/2023/02/11/solow-model/"/>
    <url>/2023/02/11/solow-model/</url>
    
    <content type="html"><![CDATA[<h2 id="一基本假设">一、基本假设</h2><h3 id="生产过程">1.生产过程</h3><p>我们首先假设，一个经济体在超长期中的生产过程，可以被分成无数个相继发生的短期生产过程。在经济体的每一期生产过程中，都有一定量的资本和劳动相结合，在一定的技术条件下，生产出一定量的产品。这些产品一部分用于这一期的消费，还有一部分用于投资，为下一期的生产做准备。</p><p>单个短期生产过程的图示为： <pre><code class=" mermaid">flowchart LRcapital(资本 K) &amp; labour(劳动 L) &amp; efficiency(劳动效率 E) --&gt; factors(生产要素) -- 生产过程 --&gt; product(产出 Y) --&gt; investment(投资 I) &amp; consumption(消费 C)</code></pre></p><p>首先考虑离散情形。 我们假设每一期生产过程所用时长均为 <spanclass="math inline"><em>h</em></span>。上述所有量首先可以被分为两类：</p><ul><li>存量：<spanclass="math inline"><em>K</em>, <em>L</em>, <em>E</em></span></li><li>流量：<spanclass="math inline"><em>Y</em>, <em>I</em>, <em>C</em></span></li></ul><p>我们认为这些量都是 <span class="math inline"><em>t</em></span>的函数，但是其含义却不尽相同：</p><ul><li>对于存量而言，它的含义是 <span class="math inline"><em>t</em></span>时刻该存量有多少；</li><li>对于流量而言，它的含义是 <spanclass="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内该流量有多少。</li></ul><p>下面考虑连续情形，即 <span class="math inline"><em>h</em> → 0</span>的情形。此时每个生产过程耗费的时间都是无穷小量，故其对应的产出、投资、消费也是无穷小量。为了让这些量仍然具有意义，我们必须修改它们的定义，即将流量修改为该变量在<span class="math inline"><em>t</em></span> 时刻的增长速率。</p><h3 id="生产函数">2.生产函数</h3><h4 id="总生产函数">2.1.总生产函数</h4><p>我们假设生产要素和产出之间存在函数关系，称作总生产函数 <spanclass="math inline"><em>F</em></span>。 具体来说，<spanclass="math inline"><em>F</em></span> 的定义是 <spanclass="math display">$$\begin{align*}    F:\mathbb{R}\times\mathbb{R}&amp;\to\mathbb{R}\\    (K,LE)&amp;\to Y.\end{align*}$$</span> 在离散情形下，<span class="math inline"><em>F</em></span> 将<span class="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了<span class="math inline">[<em>t</em>, <em>t</em> + <em>h</em>)</span>时间段内的产出； 在连续情形下，<spanclass="math inline"><em>F</em></span> 将 <spanclass="math inline"><em>t</em></span> 时刻的资本和有效工人对应到了 <spanclass="math inline"><em>t</em></span> 时刻产出的增长速率。</p><p>为了方便研究，我们假设连续情形下 <spanclass="math inline"><em>F</em></span> 是可微的。</p><h4 id="规模报酬不变">2.2.规模报酬不变</h4><p>我们假设总生产函数具有规模报酬不变性质，即如果等比例地增加生产要素，产出也会按相同比例增加。在数学上，这意味着 <span class="math inline"><em>F</em></span>具有齐次性，即对任意的实数 <spanclass="math inline"><em>x</em>, <em>y</em>, <em>λ</em></span> 有 <spanclass="math inline"><em>F</em>(<em>λ</em><em>x</em>,<em>λ</em><em>y</em>) = <em>λ</em><em>F</em>(<em>x</em>,<em>y</em>)</span>。</p><h4 id="总资本边际产量">2.3.总资本边际产量</h4><p>在离散情形下，资本的边际产量 <span class="math inline">MPK</span>是生产要素组合的函数，含义是在该要素组合下，增加一单位资本带来的额外产出，即<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em>(<em>K</em>+1,<em>L</em><em>E</em>) − <em>F</em>(<em>K</em>,<em>L</em><em>E</em>).</span></p><p>很明显，在连续情形下，<span class="math inline">MPK</span> 的定义是<spanclass="math display">MPK(<em>K</em>,<em>L</em><em>E</em>) := <em>F</em><sub>1</sub>(<em>K</em>,<em>L</em><em>E</em>).</span></p><h4 id="人均总生产函数">2.4.人均总生产函数</h4><p>在 Solow模型中，我们十分关注人均情形，但这里的人均情形是有效工人意义下的人均，例如人均资本被定义为总资本比有效工人，即人均资本<span class="math inline">$k:=\frac{K}{LE}$</span>。</p><p>由总生产函数的齐次性，不难得到 <span class="math display">$$y=\frac{Y}{LE}=\frac{1}{LE}F(K,LE)=F\left(\frac{K}{LE},1\right)=F(k,1).$$</span></p><p>但我们并不能就此断言 <span class="math inline"><em>k</em></span> 与<span class="math inline"><em>y</em></span> 之间存在函数关系。 因为<span class="math inline"><em>k</em></span>对应的可能生产要素组合构成了集合 <spanclass="math inline">{(<em>λ</em><em>k</em>,<em>λ</em>)|<em>λ</em> ∈ ℝ}</span>，即该集合中每一种生产要素组合对应的人均资本都是<span class="math inline"><em>k</em></span>。我们必须证明，对集合中的每一种生产要素组合，其对应的人均产量 <spanclass="math inline"><em>y</em></span> 都是相同的，这样 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间才存在函数关系。 否则，若一个<span class="math inline"><em>k</em></span> 对应了多个 <spanclass="math inline"><em>y</em></span>，则两者之间不存在函数关系。</p><p><em>证明：</em> 因为 <span class="math display">$$y=\frac{1}{\lambda}F(\lambda k,\lambda)=F(k,1),$$</span> 所以所有可能生产要素组合的 <spanclass="math inline"><em>y</em></span> 的值都等于 <spanclass="math inline"><em>F</em>(<em>k</em>,1)</span>，因而 <spanclass="math inline"><em>k</em></span> 和 <spanclass="math inline"><em>y</em></span> 之间存在函数关系。</p><p><em>证毕。</em></p><p>不妨将该函数记作 <spanclass="math inline"><em>f</em></span>，称作人均总生产函数，即 <spanclass="math display"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1).</span></p><h4 id="人均资本边际产量">2.5.人均资本边际产量</h4><p>与总生产函数类似，我们也可以为人均总生产函数定义资本边际产量。离散情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>(<em>k</em>+1) − <em>f</em>(<em>k</em>).</span></p><p>连续情形： <spanclass="math display">MPK(<em>k</em>) := <em>f</em>′(<em>k</em>).</span></p><p>这里就产生了一个问题：人均情形的 <span class="math inline">MPK</span>和总的情形的 <span class="math inline">MPK</span> 的关系是什么。对于离散情形，两者并不存在确切的数量关系。 下面考虑连续情形：</p><blockquote><p>引理：若函数 <span class="math inline"><em>g</em></span> 是 <spanclass="math inline"><em>k</em></span> 阶齐次的，那么它的任一偏导数 <spanclass="math inline">∂<em>g</em>/∂<em>x</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>k</em> − 1</span> 阶齐次的。</p></blockquote><p>因为总生产函数 <span class="math inline"><em>F</em></span>是一阶齐次的（即齐次函数），所以 <spanclass="math inline"><em>F</em></span> 的偏导数 <spanclass="math inline"><em>F</em><sub>1</sub></span>是零阶齐次的，这意味着对任意的实数 <spanclass="math inline"><em>k</em>, <em>λ</em></span> 有 <spanclass="math display">MPK(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>λ</em><em>k</em>,<em>λ</em>) = <em>F</em><sub>1</sub>(<em>k</em>,1) = <em>f</em>′(<em>k</em>) = MPK(<em>k</em>).</span>由此可以看出，人均资本 <span class="math inline"><em>k</em></span> 的<span class="math inline">MPK</span>，与其对应的各种总的生产要素组合<span class="math inline">(<em>λ</em><em>k</em>,<em>λ</em>)</span> 的<span class="math inline">MPK</span> 是相同的。</p><h3 id="符号表">3.符号表</h3><table><thead><tr class="header"><th style="text-align: center;">含义</th><th style="text-align: center;">符号</th><th style="text-align: center;">定义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">社会总资本</td><td style="text-align: center;"><spanclass="math inline"><em>K</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均资本</td><td style="text-align: center;"><spanclass="math inline"><em>k</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{K}{LE}$</span></td></tr><tr class="odd"><td style="text-align: center;">社会总劳动</td><td style="text-align: center;"><spanclass="math inline"><em>L</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">社会总产出</td><td style="text-align: center;"><spanclass="math inline"><em>Y</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均产出</td><td style="text-align: center;"><spanclass="math inline"><em>y</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{Y}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总投资</td><td style="text-align: center;"><spanclass="math inline"><em>I</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均投资</td><td style="text-align: center;"><spanclass="math inline"><em>i</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{I}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">社会总消费</td><td style="text-align: center;"><spanclass="math inline"><em>C</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">人均消费</td><td style="text-align: center;"><spanclass="math inline"><em>c</em></span></td><td style="text-align: center;"><spanclass="math inline">$\frac{C}{LE}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率</td><td style="text-align: center;"><spanclass="math inline"><em>E</em></span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>F</em></span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">人均总生产函数</td><td style="text-align: center;"><spanclass="math inline"><em>f</em></span></td><td style="text-align: center;"><spanclass="math inline"><em>f</em>(<em>k</em>) := <em>F</em>(<em>k</em>,1)</span></td></tr><tr class="odd"><td style="text-align: center;">储蓄率</td><td style="text-align: center;"><spanclass="math inline"><em>s</em></span></td><td style="text-align: center;">产出中未消费的比例</td></tr><tr class="even"><td style="text-align: center;">折旧率</td><td style="text-align: center;"><spanclass="math inline"><em>δ</em></span></td><td style="text-align: center;">资本损耗的比例</td></tr><tr class="odd"><td style="text-align: center;">劳动力增长率</td><td style="text-align: center;"><spanclass="math inline"><em>n</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaL}{L}$</span> 或 <span class="math inline">$\frac{L'}{L}$</span></td></tr><tr class="even"><td style="text-align: center;">劳动效率增长率</td><td style="text-align: center;"><spanclass="math inline"><em>g</em></span></td><td style="text-align: center;"><span class="math inline">$\frac{\DeltaE}{E}$</span> 或 <span class="math inline">$\frac{E'}{E}$</span></td></tr><tr class="odd"><td style="text-align: center;">资本边际产量</td><td style="text-align: center;"><spanclass="math inline">MPK</span></td><td style="text-align: center;"></td></tr></tbody></table><h2 id="二资本增长方程">二、资本增长方程</h2><p>Solow 模型描述了资本的增长规律，本节探讨的资本增长方程是 Solow模型最核心的部分。</p><h3 id="资本的增长过程">1.资本的增长过程</h3><p>如果我们把资本看作单个生产过程的起点，那么整个过程就变为资本的增长过程：<pre><code class=" mermaid">flowchart TB    capital(资本) -- 投入生产 --&gt; factors(生产要素) -- 生产 --&gt; product(产品) --&gt; investment(投资) -- 资本更新 --&gt; capital(资本)</code></pre></p><p>如果我们进一步将资本以外的环节全部抽象成生产过程，资本的增长过程就变为：<pre><code class=" mermaid">flowchart TB    capital(资本) --投入生产--&gt; produce(生产)    produce(生产) --资本更新--&gt; capital(资本)</code></pre></p><p>资本首先作为生产要素进入生产过程。资本在生产过程中资本会有一定的损耗，称作<strong>资本折旧</strong>，这是资本在增长过程中减少的部分。生产出的产品一部分用于消费，另一部分用于<strong>投资</strong>，这是资本在增长过程中增加的部分。Solow模型最核心的思想是，资本净增长等于投资（增加的部分）减去资本折旧（减少的部分），即：<span class="math display">资本增量 = 投资 − 资本折旧.</span></p><p>产出中未消费的比例称作<strong>储蓄率</strong> <spanclass="math inline"><em>s</em></span>，所以每次生产完成后未消费的产出的量是<span class="math inline"><em>s</em><em>Y</em></span>。 根据<ahref="https://en.wikipedia.org/wiki/Saving_identity">储蓄-投资恒等式</a>，未消费的部分即投资，所以投资的量也是<span class="math inline"><em>s</em><em>Y</em></span>。</p><p>资本折旧占资本的比例称作<strong>折旧率</strong> <spanclass="math inline"><em>δ</em></span>，所以每次生产损耗的资本是 <spanclass="math inline"><em>δ</em><em>K</em></span>。</p><h3 id="总资本增长方程">2.总资本增长方程</h3><p>首先考虑离散情形。 用符号代替上面的资本增长方程，就得到： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>Y</em><sub><em>t</em></sub> − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub></span>再用 <spanclass="math inline"><em>Y</em><sub><em>t</em></sub> = <em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>)</span>代入上式，就得到离散情形下的总资本增长方程： <spanclass="math display"><em>Δ</em><em>K</em><sub><em>t</em></sub> = <em>s</em><sub><em>t</em></sub><em>F</em>(<em>K</em><sub><em>t</em></sub>,<em>L</em><sub><em>t</em></sub><em>E</em><sub><em>t</em></sub>) − <em>δ</em><sub><em>t</em></sub><em>K</em><sub><em>t</em></sub>.</span></p><p>连续情形的总资本增长方程同理可得： <span class="math display">$$\frac{dK_t}{dt}=s_tF(K_t,L_tE_t)-\delta_tK_t.$$</span></p><h3 id="人均资本增长方程">3.人均资本增长方程</h3><p>从总资本增长方程出发，我们不难得到人均资本增长方程。</p><p>离散情形的人均资本增长方程： <span class="math display">$$\Delta k_t=\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \Delta k_t    =&amp;\Delta\left(\frac{K_t}{L_tE_t}\right)    =\frac{(\Delta K_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\DeltaE_t]}{(L_{t+1}E_{t+1})(L_tE_t)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\frac{(\DeltaK_t)L_tE_t-K_t[(\Delta L_t)E_t+L_t\Delta E_t]}{(L_tE_t)^2}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(代入总资本增长方程)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}\left[s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{\DeltaL_t}{L_t}+\frac{\DeltaE_t}{E_t}\right)\right]\;\text{(由生产函数的齐次性)}\\    =&amp;\frac{L_tE_t}{L_{t+1}E_{t+1}}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t]\\    =&amp;\frac{1}{n_tg_t+n_t+g_t+1}[s_tf(k_t)-(\delta_t+n_t+g_t)k_t].\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程： <span class="math display">$$\frac{dk_t}{dt}=s_tf(k_t)-(\delta_t+n_t+g_t)k_t.$$</span> <em>证明：</em> <span class="math display">$$\begin{align*}    \frac{dk_t}{dt}    =&amp;\left(\frac{K_t}{L_tE_t}\right)'    =\frac{K'_tL_tE_t-K_t(L'_tE_t+L_tE'_t)}{(L_tE_t)^2}\\    =&amp;\frac{1}{L_tE_t}(s_tF(K_t,L_tE_t)-\delta_tK_t)-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(代入总资本增长方程)}\\    =&amp;s_tF\left(\frac{K_t}{L_tE_t},1\right)-\delta_t\frac{K_t}{L_tE_t}-\frac{K_t}{L_tE_t}\left(\frac{L'_t}{L_t}+\frac{E'_t}{E_t}\right)\;\text{(由生产函数的齐次性)}\\    =&amp;s_tf(k_t)-(\delta_t+n_t+g_t)k_t.\end{align*}$$</span> <em>证毕。</em></p><p>连续情形的人均资本增长方程是 Solow 模型最常见的表述。</p>]]></content>
    
    
    <categories>
      
      <category>经济学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>西方经济学</tag>
      
      <tag>宏观经济学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ机器人搭建教程</title>
    <link href="/2023/02/06/qq-bot-tutorial/"/>
    <url>/2023/02/06/qq-bot-tutorial/</url>
    
    <content type="html"><![CDATA[<p>本文先简要阐述现在流行的QQ机器人的工作原理，再介绍一个机器人搭建案例。</p><p>要编写一个QQ机器人，至少需要实现两种功能：</p><ol type="1"><li>机器人和QQ服务器之间的通信。</li><li>机器人对QQ消息的处理。</li></ol><h2id="一机器人和qq服务器之间的通信">一、机器人和QQ服务器之间的通信</h2><p>机器人和QQ服务器之间有以下几种通信方式。</p><h3 id="通信方式1直接通信">1.通信方式1：直接通信</h3><!-- > 通信方式1：【QQ服务器】---QQ协议---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(机器人)</code></pre><p>QQ客户端与服务端之间依赖于一套特定协议来通信，暂且称作<strong>QQ协议</strong>。如果我们知道了协议的具体内容，就可以伪装成QQ客户端，按这套协议直接向服务端发送信息，并且按这套协议解析服务端发来的信息。</p><p>但该做法存在以下几个问题：</p><ul><li>逆向工程。QQ的协议由腾讯公司私有，我们并不知道其具体内容。所以我们需要对QQ客户端进行逆向工程，但这个工作相当复杂。</li><li>网络编程。为了发送QQ消息，我们需要编写相应代码来封装、发送QQ消息；为了接收QQ消息，我们也需要编写相应代码来接收、解析QQ消息。</li></ul><p>但是在编写机器人时，我们最应该关心的是机器人处理QQ消息的逻辑，而不是这些底层且复杂的工作。</p><h3id="通信方式2通过中间层进行通信">2.通信方式2：通过中间层进行通信</h3><!-- > 通信方式2：【QQ服务器】---QQ协议---【中间层】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中间层)-- 库调用 ---id3(机器人)</code></pre><p>为了解决上述两个问题，我们可以编写一个<strong>中间层</strong>。一方面，中间层与QQ服务器进行具体的通信；另一方面，中间层为我们提供简单易用的<strong>库接口</strong>。在编写机器人时，我们只需要直接调用这些库接口，让中间层去进行具体的通信工作。这样，逆向工程和网络编程就由编写中间层的程序员完成；而编写机器人的程序员不再需要操心这些底层问题，只需了解库接口如何调用。</p><p>这种通信方式依然存在一个问题：通常来说，编写机器人和编写中间层的语言应该是相同的。例如，我们使用的是实现为Java库的中间层，那么我们只能使用Java语言来调用中间层的接口。于是，编写机器人的语言种类受到了限制。</p><h3id="通信方式3通过中间层和适配器进行通信">3.通信方式3：通过中间层和适配器进行通信</h3><!-- > 通信方式3：【QQ服务器】---QQ协议---【中间层】---中间层协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(中间层)-- 中间层协议 ---id3(适配器)-- 库调用 ---id4(机器人)</code></pre><p>为了让各种语言都可以使用同一个中间层，我们可以将中间层实现为独立运行的软件，提供<strong>通用的本地网络接口</strong>（例如：HTTP，Websocket，ReverseWebsocket），制订一套简单的中间层接口协议。这样，不管我们使用什么编程语言，只要按协议调用这些接口，就可以使用中间层的功能。</p><p>但提升中间层通用性带来的代价是，我们又要面对网络编程这个麻烦事（机器人和中间层之间通过本地网络通信）。为了回避网络编程，我们可以为每种编程语言开发相应的<strong>适配器</strong>（实现为库），只需调用适配器提供的库接口，让适配器与中间层进行沟通。</p><blockquote><p>这种通信方式的确比前一种更加迂回。如果我们为每一种编程语言开发相应的中间层库而非适配器，就可以避免迂回。之所以不这么做，是因为开发中间层的工作量要大于开发适配器，提高中间层的通用性更加划算。</p></blockquote><h3 id="推荐的中间层mirai">4.推荐的中间层：Mirai</h3><p>常见的中间层有 Mirai，酷Q，oicq 等等。 本文推荐 <ahref="https://github.com/mamoe/mirai">Mirai</a> 的理由有：</p><ol type="1"><li>全平台通用。Mirai 由 Kotlin 语言编写，可以运行在Windows，Linux，MacOS 等操作系统上。</li><li>小巧。我电脑上的 mirai-console 只有 60 多 M。</li><li>开源。</li></ol><p>Mirai 本身是一个库，也就是说我们需要使用 Kotlin编写机器人，按照上述的<em>通信方式2</em>与QQ服务器进行通信。</p><p>但 Mirai 官方也将 Mirai 实现为了一个独立运行的程序，名为 <ahref="https://github.com/mamoe/mirai/tree/dev/mirai-console">mirai-console</a>。mirai-console 中安装了 mirai-api-http 插件后，就可以提供本地网络接口。于是我们可以使用任何编程语言，按照上述的<em>通信方式3</em>与QQ服务器进行通信。</p><h3 id="其他聊天软件">5.其他聊天软件</h3><p>上述通信方式并不局限于和QQ服务器的通信。如果我们要编写其他聊天软件的机器人，通信方式也是类似的。有些聊天软件还提供公开的接口，例如钉钉、Discord。为这些软件编写机器人时，我们就不需要中间层的帮助了。例如钉钉机器人的通信方式是：<!-- > 通信方式（钉钉）：【钉钉服务器】---DingTalk协议---【适配器】---库调用---【机器人】 --><pre><code class=" mermaid">flowchart LRid1(钉钉服务器)-- DingTalk协议 ---id2(适配器)-- 库调用 ---id3(机器人)</code></pre></p><h2 id="二机器人框架">二、机器人框架</h2><p>机器人不管为何种聊天软件编写，都具有一些类似的特点：</p><ul><li>消息驱动。通常来说，机器人是被动地处理消息，接收到特定命令时完成特定功能。</li><li>插件系统。通常机器人提供的功能不止一种。为了方便编程，我们可以将各种功能抽象为插件，实现一个插件管理系统，根据接收到的命令运行特定插件。</li><li>异步编程。要让机器人可以同时处理多个命令，需要用到异步编程。</li><li>……</li></ul><p>于是，我们可以进一步抽象出一个具有上述功能的机器人框架。它不但可以帮助我们更简单地编写一个机器人，还可以让我们的机器人具有跨聊天平台的特性。</p><p>机器人框架的种类十分丰富。选取哪一个机器人框架，取决于我们选用的语言、中间层。</p><h2 id="三机器人搭建方案">三、机器人搭建方案</h2><p>要搭建一个机器人，我们需要决定三件事：</p><ol type="1"><li>选取什么中间层。</li><li>选取什么编程语言。</li><li>选取什么机器人框架。</li></ol><blockquote><p>适配器通常包含于机器人框架内，不需要选取。</p></blockquote><p>下面提供了几种选取方案：</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: center;">中间层</th><th style="text-align: center;">编程语言</th><th style="text-align: center;">通信方式</th><th style="text-align: center;">机器人框架</th><th style="text-align: center;">mirai-console</th><th style="text-align: center;">mirai-api-http</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式2</td><td style="text-align: center;">-</td><td style="text-align: center;">✅</td><td style="text-align: center;">❌</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Kotlin</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/iTXTech/mirai-kts">Mirai Kts</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">C++</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://github.com/cyanray/mirai-cpp">mirai-cpp</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://v2.nonebot.dev/">NoneBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">Mirai</td><td style="text-align: center;">Python</td><td style="text-align: center;">通信方式3</td><td style="text-align: center;"><ahref="https://docs.alicebot.dev/">AliceBot</a></td><td style="text-align: center;">✅</td><td style="text-align: center;">✅</td></tr></tbody></table><p>更多机器人框架可以参见 <ahref="https://docs.mirai.mamoe.net/#http-%E6%8E%A5%E5%8F%A3">mirai开发文档（HTTP 接口）</a>。 方案1是将 Mirai 作为库来调用，所以不需要mirai-console 和 mirai-api-http ； 方案2是将机器人写成 mirai-console的插件，被它调用，所以需要 mirai-console。</p><p>有关 Mirai 生态的更多内容，参见 <ahref="https://docs.mirai.mamoe.net/mirai-ecology.html">mirai开发文档（生态简介）</a>。</p><h2 id="四案例miraialicebot-环境搭建">四、案例：Mirai+AliceBot环境搭建</h2><p>下面详细介绍方案6的环境搭建。<!-- > 通信方式：【QQ服务器】---QQ协议---【Mirai】---Mirai API---【AliceBot适配器】---库调用---【AliceBot】 --></p><p>方案6的通信方式： <pre><code class=" mermaid">flowchart LRid1(QQ服务器)-- QQ协议 ---id2(Mirai)-- Mirai API ---id3(AliceBot适配器)-- 库调用 ---id4(AliceBot)</code></pre></p><p>安装清单：</p><ol type="1"><li>JRE：Java 运行时。Mirai 基于 Kotlin 开发，需要 JRE 环境。</li><li>mirai-console：独立运行的中间层。</li><li>mirai-api-http：提供本地网络接口的中间层插件。</li><li>alicebot：机器人框架。</li><li>alicebot-adapter-mirai：与 alicebot 配套的 mirai 适配器。</li></ol><h3 id="安装-mirai">1.安装 Mirai</h3><p>我们可以使用 Mirai 官方提供的<ahref="https://github.com/iTXTech/mcl-installer/releases">自动安装器</a>来安装mirai-console。 如果计算机上没有 JRE，自动安装器也可以帮助安装。 &gt;mirai-console 有两个版本，一个有 GUI 界面，一个没有，详情参见 <ahref="https://github.com/mamoe/mirai/blob/dev/docs/UserManual.md">Mirai用户手册</a>。自动安装器安装的是无 GUI 界面版本。</p><p>mirai-console 安装完成后，安装目录中会出现名为 mcl(Mirai ConsoleLoader) 的脚本。 运行此脚本即可启动 mirai-console。</p><p>安装 mirai-api-http 插件可以利用 mirai-console 命令：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl --update-package net.mamoe:mirai-api-http --channel stable --<span class="hljs-built_in">type</span> plugin<br></code></pre></td></tr></table></figure></p><h3 id="初步配置-mirai">2.初步配置 Mirai</h3><p>运行 mcl 脚本来启动 mirai-console： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./mcl<br></code></pre></td></tr></table></figure></p><p>mirai-console 成功启动后，可以输入 <code>/help</code>查看帮助文档。</p><p>登录 QQ 账号的命令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/login &lt;qq&gt; [password] [protocol]<br></code></pre></td></tr></table></figure></p><p>设置自动登录： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autoLogin add &lt;account&gt; &lt;password&gt;<br></code></pre></td></tr></table></figure></p><p>退出 mirai-console： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/stop<br></code></pre></td></tr></table></figure></p><p>mirai-console 支持的登录协议有<code>ANDROID_PHONE</code>、<code>ANDROID_PAD</code>、<code>ANDROID_WATCH</code>、<code>MACOS</code>、<code>IPAD</code>五种。 QQ服务器通过登录协议来识别登录设备的种类。 mirai-console 默认使用<code>ANDROID_PHONE</code> 协议登录，因此 mirai 会将自身伪装成安卓手机。如果想要让手机和 mirai-console同时登录一个账号，我们可以将登录协议切换为<code>ANDROID_PAD</code>，因为QQ允许安卓手机和平板同时登陆。切换自动登录使用的协议： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mirai-console">/autologin setConfig &lt;account&gt; protocol &lt;protocol&gt;<br></code></pre></td></tr></table></figure></p><h3 id="mirai-console-目录结构">3.mirai-console 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Directory">.<br>├── config<br>│   ├── Console<br>│   │   ├── AutoLogin.yml<br>│   │   └── ...<br>│   └── net.mamoe.mirai-api-http<br>│       └── setting.yml<br>├── plugins<br>└── ...<br></code></pre></td></tr></table></figure><ul><li><code>./config/Console/AutoLogin.yml</code>文件包含自动登录的相关配置。</li><li><code>./config/net.mamoe.mirai-api-http/setting.yml</code> 文件包含mirai-api-http 插件的相关配置。安装该插件并运行 mirai-console之后才会生成此文件。</li><li><code>./plugins</code> 文件夹用于存放 mirai-console插件。mirai-console 启动后会自动加载该文件夹中的插件。</li></ul><blockquote><p>mirai-console 的插件可以在 <ahref="https://mirai.mamoe.net/category/11/%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83">Mirai论坛</a> 下载。</p></blockquote><h3 id="安装-alicebot">4.安装 AliceBot</h3><p>使用 pip 安装即可。 安装 alicebot： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot<br></code></pre></td></tr></table></figure> 安装alicebot-adapter-mirai： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install alicebot-adapter-mirai<br></code></pre></td></tr></table></figure> ### 5.配置 AliceBot 在配置AliceBot 之前建议先了解其<ahref="https://docs.alicebot.dev/guide/index.html">工作原理</a>。AliceBot 是 Python 库，并非独立运行的软件，我们需要编写 Python脚本并调用 AliceBot 库来实现一个机器人。 可以参照其<ahref="https://docs.alicebot.dev/guide/getting-started.html">开发文档（快速上手）</a>编写一个简单的AliceBot 项目。</p><p>要让 AliceBot 正常工作，必须先对 AliceBot 和 Mirai进行配置，让它们能够正确地通信，详细配置方式参照其<ahref="https://docs.alicebot.dev/guide/basic-config.html">开发文档（基本配置）</a>和<ahref="https://docs.alicebot.dev/guide/mirai-adapter.html">开发文档（Mirai协议适配器）</a>。 配置的关键之处在于让 AliceBot 和 Mirai选择同一套网络协议，并且使用相同的 <code>verify_key</code>。</p><h3 id="运行">6.运行</h3><p>mirai-console 和 AliceBot机器人脚本是两个独立的程序，它们之间通过本地网络接口通信。因此，在运行机器人时，我们必须同时运行两个程序。至于两个程序的存放路径则是无关紧要的，我们可以把它们放在同一目录下，也可以不这么做。我们可以将自己或他人编写的 AliceBot插件放在指定的插件目录下，它就会自动运行该插件。 AliceBot插件的编写方式参考<ahref="https://docs.alicebot.dev/guide/plugin-basics.html">开发文档(插件基础)</a>。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QQ机器人</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
